The Commuto Protocol
Version 0.2

The Commuto Protocol allows users to exchange fiat currencies and stablecoins without the use of a trusted intermediary.

The Commuto protocol is intended to be used with either a graphical, text-based/command line or API interface, to allow
easy interaction with the core protocol functionality. These interfaces will make up a peer-to-peer network across
which offers will be broadcast, so each user will have a complete local copy of the Commuto Protocol's decentralized
offer book. However, this document focuses only on describing the functionality of the protocol, not of the various
interfaces, which are described in the Commuto Interface Specification.

The Commuto Protocol's name comes from the Latin word "commuto", meaning "I exchange" or "I barter."

Contract code can be viewed here: https://github.com/jimmyneutront/commuto-protocol

Motivation:
At the time of writing in August 2021, many countries are experiencing severe inflation. Honest, hardworking people,
who love their country and express their belief in the strength of its economy by holding their national currency, are
watching the purchasing power of their life savings melt away as their country's central bank rapidly inflates the
supply of national currency. In order to afford food, medicine, clothing, education and other basic necessities of life
for themselves and for their families, these people have no choice but to swap their national currency for a stable
foreign currency, such as the Euro, Swiss Franc or United States Dollar.

In many parts of the world, this type of swap can be very difficult to complete. Many countries impose unfairly small
limits on the amount of national currency that an individual can exchange for foreign currency. Strict sanctions,
created by well-meaning world leaders and intended to target cruel rulers of oppressive regimes, often catch innocent
civilians in the crossfire, cutting off their access to financial services and further confounding their efforts to
attain financial stability. Exorbitantly high fees charged by many exchange platforms take yet another chunk out of
users' savings, disproportionately affecting low income earners. And long transaction and exchange times harm those who
may need to quickly turn a portion of their foreign-currency-denominated savings back into their national currency, to
cover unexpected expenses like medical bills.

In response to these failures of fiat currencies and the traditional banking system, stablecoins, the prices of which
are pegged to stable and widely used currencies like the Euro or US Dollar, have been created, and are on the path to
widespread adoption.

What is needed is a fast, affordable and secure tool to facilitate the exchange between fiat currencies and stablecoins.
Such a tool didn't exist, until now.

Core Principles:
The right to freely exchange one's own fairly acquired property is fundamental. In accordance with this basic principle,
the Commuto Protocol helps users swap fiat currencies and stablecoins in a fast, affordable, secure, private and
censorship-resistant manner.

The Commuto Protocol is fast because it is a decentralized application built with smart contracts. Whereas traditional
bank transfers may take hours or days, a transaction of smart-contract-powered tokens on Ethereum or Binance Smart Chain
takes mere seconds.

The Commuto Protocol is affordable because stablecoins have low transaction fees. Even high value transactions incur
fees that only amount to a few dollars at most, and in some cases, only a few cents.

The Commuto Protocol is secure because it has no trusted intermediary. All funds are handled in a decentralized and
transparent fashion by an auditable, open-source smart contract, and no 3rd party can unilaterally seize funds or
otherwise interfere with the exchange protocol.

The Commuto Protocol is private because users remain in control of their personal information. Their data is never made
public or stored in a central location. This means that there is no database for malicious actors to target in an
attempt to identify users or steal their information.

The Commuto Protocol is censorship-resistant because it is private and has no single point of failure. Because it is
built on technology like Ethereum and Binance Smart Chain, an entity attempting to censor it must censor the execution
of smart contracts on these platforms, which has been proven to be incredibly difficult to do as they have been built
from the ground up with censorship-resistance as a core tenet.

The Protocol:
The Commuto Protocol can be best described as a sequence of simple steps. The Commuto Protocol will support multiple
stablecoins (such as DAI, USDC, BUSD, USDT) and many national currencies, so this document will refer to a nonspecific
stablecoin with the symbol STBL, and a generic national currency with the symbol FIAT. Sellers have STBL and want FIAT,
and buyers have FIAT and want STBL.
A Commuto Interface Id is an array of bytes that refers to a specific Commuto Interface instance, and contains a
SHA-256 hash of a public key belonging to a Commuto Interface instance.
1) The maker will create an offer by calling the openOffer function, specifying:
bytes16 offerID: a Universally Unique Identifier (UUID) to uniquely identify the offer
Offer newOffer:
    bool isCreated: used by contract code to check for offer existence, will be set to true by openOffer
    address maker: the maker's address, will be set to msg.sender by openOffer
    bytes interfaceId: the maker's Commuto Interface Id
    StablecoinType stablecoinType: the type of stablecoin to be swapped
    uint256 amountLowerBound: the lower bound of the range of amount of STBL to be swapped
    uint256 amountUpperBound: the upper bound of the range of amount of STBL to be swapped
    uint256 securityDepositAmount: the amount of STBL to be used as a security deposit which must be not less than 10%
        of amountLowerBound
    SwapDirection swapDirection: whether the offer is in the BUY or SELL direction
    bytes price: the price of the offer, in the format (amount of FIAT) per (1 STBL)
    bytes[] settlementMethods: the names of the settlement methods to be used for settlement in UTF-8 byte format
    uint256 protocolVersion: a version number describing the version of the Commuto Protocol for which the offer is
        is being created
    bytes32 extraData: a SHA-256 hash of any extra information necessary for the buyer to send FIAT payment to the
        seller, such as a username, phone number, etc.
This will add the offer to a map of all offers and the settlement method information to a map of supported settlement
methods for each offer. This will also lock the maker's security deposit amount plus a 1% of amountUpperBound fee of
STBL in escrow. This will then emit an OfferOpened event, specifying the new offer id and the maker's interface Id. Then
the maker will broadcast the offer across the peer-to-peer network.

2) The taker will take the swap offer by calling the takeOffer function, specifying:
bytes16 offerID: the id of the offer to be taken
Swap newSwap:
    bool isCreated: used by contract code to check for swap existence, will be set to true by takeOffer
    bool requiresFill: used by contract code to determine if maker has deposited STBL, in the case of a maker-as-seller
        offer
    address maker: the maker's address
    bytes makerInterfaceId: the maker's Commuto Interface Id
    address taker: the taker's address
    bytes takerInterfaceId: the taker's Commuto Interface Id
    StablecoinType stablecoinType: the type of stablecoin to be swapped
    uint256 amountLowerBound: the lower bound of the range of amount of STBL to be swapped
    uint256 amountUpperBound: the upper bound of the range of amount of STBL to be swapped
    uint256 securityDepositAmount: the amount of STBL to be used as a security deposit
    uint256 takenSwapAmount: the amount of STBL to be swapped; must be >= amountLowerBound and <= amountUpperBound
    uint256 serviceFeeAmount: used by contract code, equal to 1% of takenSwapAmount
    SwapDirection swapDirection: whether the offer is in the BUY or SELL direction
    bytes price: the price of the offer, in the format (amount of FIAT) per (1 STBL)
    bytes settlementMethod: the name of the settlement method to be used for settlement in UTF-8 byte format
    uint256 protocolVersion: a version number describing the version of the Commuto Protocol on which the swap will be
        executed
    bytes32 makerExtraData: a SHA-256 hash of any extra information about the maker necessary for the buyer to send
        FIAT payment to the seller
    bytes32 takerExtraData: a SHA-256 hash of any extra information about the taker necessary for the buyer to send
        FIAT payment to the seller
This will validate all data to ensure it matches that of the offer being taken. If not, it will revert with a proper
error message. This will also lock the taker's security deposit amount plus a 1% fee of STBL in escrow. If the taker is
the seller, this will also lock the amount of STBL to be swapped in escrow. This will then mark the corresponding offer
as taken and will add the swap to a map of all swaps. This will then emit an OfferTaken event, specifying the new swap
id and the taker's interface Id.

3) If the maker of the offer is the seller, the maker fills the swap by calling the fillOffer function, specifying:
bytes16 swapID: the id of the swap to fill
This will ensure that the caller is the maker and seller and that the swap has not already been filled, and will then
lock up the amount of STBL to be swapped in escrow. This will then emit an SwapFilled event, specifying the swap id.

4) The buyer sends FIAT payment to the seller, using the payment method and user information specified in the swap, and
then reports that FIAT payment has been sent by calling the reportPaymentSent function, specifying:
bytes16 swapID: the id of the swap for which FIAT payment has been sent
This will ensure that the caller is the buyer and that payment has not already been sent. If the swap is a
maker-as-seller swap, this will make sure the swap has been filled. Then it will mark the
swap as having payment sent and will emit a PaymentSent event, specifying the swap id.

5) The seller receives the FIAT payment via the payment method specified in the offer, and then calls the
reportPaymentReceived function, specifying:
bytes16 swapID: the id of the swap for which FIAT payment has been received
This will ensure that the caller is the seller, that payment has been sent, and that payment has not already been
received. Then it will mark the swap as having payment received and will emit a PaymentReceived event, specifying the
swap id.

6) The buyer and seller then each close the swap position by calling the closeSwap function, specifying:
bytes16 swapID: the id of the swap to close
This will ensure that payment has been received and will send the two 1% service fees to the fee pool. If the caller is
the buyer and taker, this will ensure the buyer has not already closed the swap, and then will refund the taker's
security deposit and will send the swap amount to the taker. If the caller is the buyer and maker, this will ensure the
buyer has not already closed the swap, and then will refund the maker's security deposit, and will send the swap amount
and the remainder of the max service fee to the maker. If the caller is the seller and taker, this will ensure the
seller has not already closed the swap, and then will refund the taker's security deposit. If the caller is the seller
and maker, this will ensure the seller has not already closed the swap, and then will refund the maker's security
deposit and will send the remainder of the max service fee to the maker. If the caller is the buyer, this will then emit
a BuyerClosed event, specifying the swap id. If the caller is the seller, this will then emit a SellerClosed event,
specifying the swap id. Once buyer and seller have both requested swap closure, the swap is completely closed.

A maker can edit the price and supported settlement methods of their offer by calling the editOffer function,
specifying:
bytes16 offerID: the id of the swap offer to edit
Offer editedOffer:
    bool isCreated: used by contract code to check for offer existence, will be set to true by openOffer
    address maker: the maker's address, set to msg.sender by openOffer
    bytes interfaceId: the maker's Commuto Interface Id
    StablecoinType stablecoinType: the type of stablecoin to be swapped
    uint256 amountLowerBound: the lower bound of the range of amount of STBL to be swapped
    uint256 amountUpperBound: the upper bound of the range of amount of STBL to be swapped
    uint256 securityDepositAmount: the amount of STBL to be used as a security deposit which must be not less than 10%
        of amountLowerBound
    SwapDirection swapDirection: whether the offer is in the BUY or SELL direction
    bytes price: the price of the offer, in the format (amount of FIAT) per (1 STBL)
    bytes[] settlementMethods: the names of the settlement methods to be used for settlement in UTF-8 byte format
    uint256 protocolVersion: a version number describing the version of the Commuto Protocol for which the offer is
        is being created
    bytes32 extraData: a SHA-256 hash of any extra information necessary for the buyer to send FIAT payment to the
        seller, such as a username, phone number, etc.
bool editPrice: whether to apply the price of editedOffer to the open offer with id offerID
bool editSettlementMethods: whether to apply the settlement methods of editedOffer to the open offer with id offerID
This will ensure the caller of the function is the maker of the swap offer with the specified id, that the offer exists,
and that the offer has not been taken. If editPrice is true, this will set the price of the open offer to that of
editedOffer. If editSettlementMethods is true, this will remove support for all the supported settlement methods of the
open offer, and then add support to the offer for all settlement methods specified in editedOffer. This will not
consider any other properties of editedOffer.

A maker can cancel their offer by calling the cancelOffer function, specifying:
bytes16 offerID: the id of the swap offer to close
This will ensure the caller of this function is the maker of the swap offer with the specified id and that the offer has
not been taken. Then this will return to the maker their STBL, remove the offer with the corresponding id from the map
of all open offers, remove the records of that offer's accepted settlement methods, and will emit a OfferCanceled event
specifying the offer id, prompting other users to remove it from their offer books.

#TODO: Fee percentage set by token holders
Governance and Revenue Distribution:
The Commuto Protocol has a governance token, referred to henceforth as CMTO, that is also used for revenue distribution.
At the end of every week, accumulated service fees are distributed to CMTO holders, according to the percentage of all
issued CMTO tokens that they hold. CMTO token holders can also vote on the following issues/proposals:
The issuance of additional CMTO tokens
Additional miscellaneous expenses, to be deducted from the week's accumulated service fees before the remaining fees are
distributed to token holders
Adding or removing support for specific settlement methods
Addition/removal of dispute agents
Compensation of dispute agents (dispute agents and their roles in the dispute process are described below)
Resolution of disputes raised by users and unresolved by dispute agents
CMTO token holders' votes are weighted by the percentage of all issued CMTO tokens that they own.
Issuance of new CMTO tokens, miscellaneous expenses, removal of support for settlement methods, addition/removal of
dispute agents must receive approval from the holders of 50% + 1 of all issued tokens. Addition of support for fiat
currencies, compensation of dispute agents and resolution of disputes raised by users may only be approved if holders of
at least 50% of all issued tokens have voted, and if 50% + 1 of all votes cast are in favor.
Issues must be approved within one week of being proposed; otherwise they are defeated.

When new proposals are added to maps, an event will be emitted indicating the map to which the proposal was added and
the key of the new map entry.

A user can propose issuance of additional CMTO tokens by calling the corresponding Commuto Protocol smart contract
function and passing a UUID to uniquely identify the proposal, the amount of tokens to be issued, the address to which
the tokens should be sent, and a hash of a string describing why additional CMTO tokens should be issued. This will add
the new issuance request to a map of all currently open issuance requests. The user will then broadcast this data, along
with the description string in its entirety, across the peer-to-peer network. If the issuance request is approved, the
user can call the corresponding Commuto Protocol smart contract function, which will issue the amount of CMTO specified
in the request to the address specified in the request.

A user can propose an additional miscellaneous expense by calling the corresponding Commuto Protocol smart contract
function and passing a UUID to uniquely identify the proposal, the amount of STBL to be issued, the address to which the
STBL should be sent, and a hash of a string describing why this expense is necessary. This will add a new miscellaneous
expense proposal to a map of all currently open miscellaneous expense proposals. The user will then broadcast this data,
along with the description string in its entirety, across the peer-to-peer network. If the miscellaneous expense request
is approved, the user can call the corresponding Commuto Protocol smart contract function, which will send the amount of
STBL specified in the proposal from the pool of accumulated service fees to the address specified in the proposal

A settlement method is a piece of information that describes the FIAT denomination that will be paid in exchange for
STBL and the method by which that FIAT will be transferred. A user can propose the addition or removal of support for a
specific settlement method by calling corresponding Commuto Protocol smart contract function and passing a UUID to
uniquely identify the proposal, the name of the of the settlement method (in the format "SYM-PMName" where SYM is the
symbol of the settlement method's FIAT and PMName is the name of the settlement method's payment method) in its UTF-8
byte representation, an indication of whether support should be added or removed, and a hash of a string describing why
support for this settlement method should be added or removed. This will add a new settlement method support proposal to
a map of all currently open settlement method support proposals. The user will then broadcast this data, along with the
description string in its entirety, across the peer-to-peer network. If the settlement method support proposal is
approved, the user can call the corresponding Commuto Protocol smart contract function, which will implement the change
specified in the proposal in the map and array of supported settlement methods in the Commuto Protocol.

A user can request the addition of a new dispute agent to the Commuto Protocol's list of dispute agents by calling the
corresponding Commuto Protocol smart contract function and passing a UUID to uniquely identify the proposal, the dispute
agent candidate's public verification key, the dispute agent candidate's Commuto Interface Id, and a hash of a string
describing why the candidate is qualified for the role of dispute agent. This will add a proposal for the addition of a
dispute agent to a map of all currently open proposals for the addition of a dispute agent. The user will then broadcast
this data, along with the description string in its entirety, across the peer-to-peer network. If the issuance request
is approved, the user can call the corresponding Commuto Protocol smart contract function, which will require the newly
approved dispute agent to lock 10000 STBL in escrow, and will append the newly approved dispute agent's public
verification key and Interface Id to the Commuto Protocol's list of dispute agents. When a dispute agent wishes to be
removed from the Commuto Protocol's list of dispute agents, they can request their removal via a process similar to that
of adding a dispute agent, but when such a proposal is approved, the former dispute agent will call the corresponding
Commuto Protocol smart contract function which will remove the former dispute agent's information from the Commuto
Protocol's list of dispute agents and return the former agent's 10000 STBL deposit.

A dispute agent can request compensation for having successfully resolved disputes by calling the corresponding Commuto
Protocol smart contract function and passing a UUID to uniquely identify the proposal, the UUID of the disputed swap,
the requested amount of STBL for compensation, the dispute agent's signed message describing the dispute resolution, and
a hash of a string explaining why the dispute agent deserves compensation for resolving this dispute. This will
determine if the dispute was actually resolved by the resolution signed by this dispute agent, and if so, will add a
proposal for compensation of a dispute agent to a map of all currently open dispute agent compensation proposals. The
user will then broadcast this data, along with the compensation justification string in its entirety, across the
peer-to-peer network. CMTO token holders may request more information from the dispute agent, via a chat feature in a
Commuto Interface. The default compensation for dispute agents is one third of the combined service fees for the
disputed swap.  If the dispute agent compensation request is approved, the dispute agent can call the corresponding
Commuto Protocol smart contract function, which will send the amount of STBL specified in the compensation request from
the pool of accumulated service fees to the dispute agent.

If dispute agents are unable to resolve a disputed swap within 1 week using the process described below, a user may open
dispute resolution to CMTO token holders, who may approve a dispute resolution by voting. This dispute resolution
process is described below as well.

Dispute Process:
In the process described above, both the buyer and seller have opportunities to misbehave and attempt to obtain payment
from the other party without sending payment themselves. Additionally, other issues may arise during the swap, such as
the buyer becoming unable to send FIAT payment, or the seller becoming unable to receive FIAT. In the event of such
issues, users can raise a dispute to request intervention from dispute agents.

Dispute agents are neutral, unbiased 3rd parties who hear arguments from both the buyer and seller concerning what went
wrong during the swap, and determine who should receive the STBL still held in escrow. The Commuto Protocol maintains a
list of all dispute agents, each agent's Commuto Interface Address, and each agent's public key which can be used to
verify signatures of messages sent by each dispute agent.

A user can raise a dispute and request intervention from a refund agent through the following process:

1) A user raises a dispute by calling the Commuto Protocol smart contract function to raise a dispute, passing the
swap's UUID. The Commuto Protocol randomly assigns 3 dispute agents from the Commuto Protocol's list of active dispute
agents to the swap, and emits an event notifying the dispute agents that a dispute has been raised. Both users send
information about the swap and their Commuto Interface Addresses to all three dispute agents over the peer-to-peer
network via a Commuto Interface.

2) Through the Commuto Interface, each user enters a private chat room with the three dispute agents and explains the
circumstances surrounding the dispute, which may involve problems sending or receiving FIAT payment, an unresponsive
peer, or other reason. The dispute agents also enter a private chat room amongst themselves to discuss a resolution. The
dispute agents have one week to determine a resolution to the dispute. They determine the amounts of STBL held in escrow
that the buyer and seller should receive, and then they each sign an identical copy of a message containing these
amounts. Then each dispute agent sends this signed message to each user.

3) Either user can request dispute closure by calling The Commuto Protocol smart contract function to request disputed
swap closure, passing the swap's UUID and signed dispute resolution messages from at least 2 out of the 3 assigned
dispute agents. When the dispute is closed, STBL is sent to the buyer and seller as specified in the dispute resolution
message, and the swap is now completely closed.

If the dispute agents are not able to agree on a resolution within 1 week, a user can call the Commuto Protocol smart
contract function to open up dispute resolution to CMTO token holders with the following process:

1) A user opens dispute resolution to CMTO token holders by calling the Commuto Protocol smart contract function to do
so, passing the swap's UUID, the user's Commuto Interface Address and a hash of all the offer data. This will send the
swap amount as well as both users' security deposits to a specific address that temporarily holds users' funds until
CMTO token holders approve a dispute resolution result, add the swap to a map of disputed swaps for which CMTO token
holders must approve a resolution, and emit an event to notify CMTO token holders of the dispute.

2) Both the buyer and seller propose a resolution, which is a message describing the amounts of STBL held in escrow that
the buyer and seller should receive. They each broadcast these proposed resolution results across the peer-to-peer
network, and they each call the Commuto Protocol function to add a hash of their proposed result to the offer data
stored in the map of disputed swaps awaiting CMTO token holder resolution.

3) CMTO token holders vote on the resolutions proposed by the buyer and seller. CMTO token holders may vote in favor of
the buyer's proposed resolution, the seller's proposed resolution, or in favor of a third result that will approve
neither of the resolutions, and signal to the buyer and seller that they must re-submit revised resolutions. If a
proposed resolution receives the proper number of votes, the winner will call the Commuto Protocol smart contract
function to execute the approved resolution, passing the swap's UUID. The STBL held in escrow for the swap for which the
resolution has been proposed will be distributed according to the proposed resolution result, and the swap is now
completely closed.