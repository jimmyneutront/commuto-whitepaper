Commuto Interface Specification
Version 0.2 [DRAFT]

The Commuto Interface allows easy interaction with the core Commuto Protocol contract functionality. Commuto Interface
instances use the Matrix network to exchange offer information, chat messages, and other important data with each other,
composing the Commuto Interface Network. This document describes the official Commuto Interface specification.
Henceforth, "the Interface" refers to the Commuto Interface reference implementation described by this document.

The term "key object" refers to a platform-specific object representing a cryptographic key, such as SecKey on iOS or
java.security.PublicKey on Android or JVM. An asymmetric key said to be in "byte format" is a byte array containing
the key encoded as bytes according to the PKCS#1 standard. A symmetric key said to be in "byte format" is a byte array
containing the key encoded as bytes. A key said to be in "string" format is the Base64 string representation of a key in
byte format.

message JSON fields:
sender
payload
signature
recipient

Interface Interaction with Commuto Protocol:
//TODO: Include TXID in public key announcement
//TODO: Include initialization vector along with symmetric key
The following is a description of how Interfaces will interact with each other and the on-chain Commuto Protocol as
described in the whitepaper in order to execute swaps. The symbols FIAT and STBL as well as the terms "buyer" and
"seller" have the same meaning in this description as they do in the Commuto Protocol whitepaper.
The taker begins listening to the blockchain for the emission of OfferOpened events.
The maker generates a new 2048-bit RSA key pair and a new UUID. The maker prepares an EVM compatible Offer object to be
passed to the Commuto Protocol's newOffer function. The maker sets the Offer object's interfaceId property to the
SHA-256 hash of the public key in byte format of the newly generated key pair. The maker specifies the price in UTF-8
string format and sets the Offer object's price property equal to the result. The maker specifies the settlement method
to be used in UTF-8 byte format and sets the Offer object's settlementMethod property equal to the result.
The maker creates a JSON string containing their payment details with the following structure:
{
"paymentDetails":[details about maker's particular fiat payment account to be used, like a cashtag or bank account
information],
"random":[a randomly generated string to conceal payment account information from observers]
}
and generates an SHA-256 hash of this string and sets the Offer object's extraData property equal to the result.
The maker calls the Commuto Protocol's newOffer function, passing the UUID and EVM compatible Offer object and locking
the security deposit and maximum service fee in escrow. The maker begins listening to the blockchain for the emission of
the OfferOpened event corresponding to their newly opened offer. The maker creates an local offer object with all the
information specified in their EVM compatible Offer object as well as the payment details and random string, sets the
offer object's status property to "newOfferTxPublished" and stores this object locally. When the maker detects the
emission of the OfferOpened event corresponding to their newly opened offer, they set the offer object's status to
"awaitingPKAnnouncement" and create the following JSON string:
{
"sender":[the interface id used in offer creation],
"msgType":"pka", (pka -> public key announcement)
"payload": {
    "pubKey":[the public key from which the interface id used was derived in string format]
    "offerId":[the UUID of the newly created offer in UTF-8 string format]
}
"signature":[a Base64 string encoded signature of the SHA-256 hash of the value in the payload field, signed with the
private key corresponding to the interface id in the "sender" field]
}
and then send this string as a message in the Commuto Interface Network (CIN) Matrix room. When the message is
successfully sent, the maker updates the offer's status to "offerOpened". The maker begins listening to the blockchain
for the emission of an OfferTaken event corresponding to their open offer.
When the taker detects the emission of the maker's OfferOpened event, they begin listening to the CIN Matrix room for a
message in JSON string format with the "msgType" field equal to "pka", the "sender" field equal to the interfaceId
specified in the emitted OpenOffer event, and the ["payload"]["offerId"] field equal to the offer id specified in the
emitted OpenOffer event. If the taker finds such a message, they generate an SHA-256 hash of the value in the
["payload"]["pubKey"] field and compare it to the value in the "sender" field. If they do not match, the taker discards
the message and continues to listen for a valid message. If they do match, the taker creates a public key object using
the value in the ["payload"]["pubKey"] field and attempts to verify the signature with it. If signature verification
fails, the taker discards the message and continues to listen for a valid message. If signature verification succeeds,
the taker associates the maker's public key with the maker's interface id and stores them locally. The taker calls the
Commuto Protocol's getOffer function and passes the offer id specified in the public key announcement message, to get
the terms of the offer. The taker decides to take the offer and prepares an EVM compatible Swap object corresponding to
the previously obtained Solidity Offer object, generating and storing a new 2048-bit RSA key pair and deriving the key
pair's corresponding interface id, the SHA-256 hash of the new public key in byte format.
The taker prepares a JSON string containing their payment details with the following structure:
{
"paymentDetails":[details about taker's particular fiat payment account to be used, like a cashtag or bank account
information],
"random":[a randomly generated string to conceal payment account information from observers]
}
and generates an SHA-256 hash of this string and sets the Swap object's takerExtraData property equal to the result.
The taker calls the Commuto Protocol's takeOffer function, passing the UUID of the offer to be taken and the EVM
compatible Swap object and locking the required amount of STBL in escrow: if the taker is the buyer, this locks the
taker's security deposit and service fee in escrow; if the taker is the seller, this also locks the swap amount in
escrow. The taker begins listening to the blockchain for the emission of the OfferTaken event corresponding to the newly
taken swap. The taker creates a swap object with all the information specified in their EVM compatible Swap object as
well as the base currency and payment details, sets the swap object's status property to "takeOfferTxPublished" and
stores this object locally. When the taker detects the emission of the OfferTaken event corresponding to the new swap,
they set the swap object's status to "awaitingPKAnnouncement" and create the following two JSON strings:
{
"msgType":"takerInfo"
"pubKey":[the public key from which the interface id in the "sender" field was derived in string format]
"swapId":[the UUID of the newly taken swap in UTF-8 string format]
"takerExtraData":[the string from which the maker derived the hash supplied as takerExtraData when taking the offer,
including the taker's payment details and random string]
}
and
{
"sender":[the taker's newly created interface id],
"recipient":[the maker's interface id],
"encryptedKey":[key used to encrypt payload, encrypted with the maker's public key]
"payload":[encrypted payload].
"signature":[a Base64 string encoded signature of the SHA-256 hash of the encrypted value in the payload field, signed
with the private key corresponding to the interface id in the "sender" field]
}
Then the taker generates an AES-256 key, encrypts the first string with it, and sets the "payload" field in the second
JSON string equal to the Base64 string encoded result. The taker retrieves the maker's public key from storage, encrypts
the AES key using the maker's public key, and sets the "encryptedKey" field in the second string to the Base64 string
encoded result. The taker sends the entire JSON string as a message in the Commuto Interface Network (CIN) Matrix room.
When the message is successfully sent, the taker updates the swap's status to "swapTaken".
The taker begins listening to the CIN Matrix room for a message in JSON string format with the "sender" field equal to
the maker's interface id and the "recipient" field equal to the taker's interface id.
When the maker detects the OfferTaken event corresponding to their offer, they transform their local offer object to a
swap object and set its status to "awaitingTakerInfo" and begin listening to the CIN Matrix room for a message with the
"sender" field equal to the taker's interface id as specified in the emitted OfferTaken event, the "recipient" field
equal to the maker's interface id. If the maker finds such a message, they retrieve the private key associated with the
interface id in the "recipient" field and use it to decrypt the value in the "encryptedKey" field and restore it into
a key object. The maker uses the new key object to decrypt the value in the "payload" field. The maker confirms that
the value in the payload's "msgType" field equals "takerInfo" and the value in the "swapId" field equals the UUID of the
swap specified in the OfferTaken event. Then the maker creates a public key object using the string in the payload's
"pubKey" field, generates a hash of the encrypted payload, and verifies the signature in the "signature" field. If
signature verification fails, the maker discards the message and continues listening for a valid message. If signature
verification succeeds, the maker generates a SHA-256 hash of the value in the payload's "takerExtraData" field. Then
the maker calls the Commuto Protocol's getSwap function, passing the UUID of the new swap. The maker compares the value
in the returned Solidity Swap object's takerExtraData field with the previously calculated hash of the payload's
"takerExtraData" field. If the two do not match, the maker discards the message and continues listening for a valid
message.
//TODO: At this ^ point, a dispute should be raised, since the taker is trying to supply bogus payment info.
If the two do match, the maker associates the taker's public key with the taker's interface id and stores them locally,
and stores the taker's payment information locally as well. The maker sets the status of their local swap object to
"receivedTakerInfo". Then the maker prepares the following JSON string:
{
"sender":[the maker's interface id],
"recipient":[the taker's interface id],
"encryptedKey":[key used to encrypt payload, encrypted with taker's public key]
"payload":[the JSON string containing payment information (the hashed value of which the maker set equal to their
original Solidity Offer object's extraData property) encrypted with the AES key that is encrypted and stored in the
"encryptedKey" field]
"signature":[a Base64 string encoded signature of the SHA-256 hash of the encrypted value in the payload field, signed
with the private key corresponding to the interface id in the "sender" field]
}
The maker then generates an AES-256 key, encrypts the JSON string containing the maker's payment information, which is
the same string that the maker hashed to obtain the value of the extraData property of the maker's original EVM
compatible Offer object, and sets the "payload" field equal to the Base64 string encoded result. The maker retrieves the
taker's public key from storage, encrypts the AES key using the taker's public key, and sets the "encryptedKey" field to
the Base64 string encoded result. The maker sends the JSON string as a message in the CIN Matrix room. When the message
is successfully sent, the maker updates the swap's status to "paymentInfoSent".
When the taker detects a message in the CIN Matrix room with the "sender" field equal to the maker's interface id and
the "recipient" field equal to the taker's id, the taker retrieves the maker's public key, generates a SHA-256 hash
of the value in the "payload" field, and verifies the signature in the "signature" field. If signature verification
fails, the taker discards the message and continues to search for a valid message. If signature verification succeeds,
the taker retrieves the private key associated with the interface id in the "recipient" field, decrypts the value in the
"encryptedKey" field, restores the AES key with the decrypted result, and decrypts the "payload" field. The taker
generates an SHA-256 hash of the decrypted "payload" field and compares it to the value of the takerExtraData property
of the EVM compatible swap object. If the two do not match, the maker discards the message and continues listening for a
valid message.
//TODO: At this ^ point, a dispute should be raised, since the taker is trying to supply bogus payment info.
If the two do match, the taker stores the maker's payment information locally and sets the status of their local swap
object to "receivedMakerInfo".
If the swap is a maker-as-seller swap, both the maker and the taker begin to listen for the emission of a SwapFilled
event corresponding to their swap. Then the maker-as-seller calls Commuto Protocol's fillSwap function, passing the UUID
of the swap and locking the swap amount of STBL in escrow. Once the maker and taker detect the emission of the
SwapFilled event corresponding to their maker-as-seller swap, they both update the status of their local swap objects to
"makerAsSellerDepositLocked".
The buyer and seller both begin to listen for the emission of a PaymentSent event corresponding to their swap.
The buyer sends fiat payment to the seller using the previously agreed-upon payment methods and details and in the
agreed  upon fiat currency denomination, and calls the Commuto Protocol's reportPaymentSent function and passes the UUID
of the swap. Once the buyer and seller detect the emission of the PaymentSent event corresponding to their swap, they
both update the status of their local swap objects to "paymentSent".
The buyer and seller both begin to listen for the emission of a PaymentReceived event corresponding to their swap.
Once the seller receives fiat payment, they call the reportPaymentReceived function, passing the UUID of the swap. Once
the buyer and seller detect the emission of the PaymentReceived event corresponding to their swap, they both update the
status of their local swap objects to "paymentReceived".
The buyer and seller both call the Commuto Protocol's closeSwap function in order to receive their STBL. When the buyer
detects the emission of a BuyerClosed event corresponding to the swap, the buyer marks their local swap object as
"closed". When the seller detects the emission of a SellerClosed event corresponding to the swap, the seller marks their
local swap object as "closed".

Commuto Interface Network Specification:
//TODO: Eventually, each Interface should have its own Matrix homeserver built in, to regularly create "throwaway" accounts
//TODO: Clarify interactions with KMService
The Interface shall have a CINService instance. The CINService is responsible for receiving and acting on requests from
other services belonging to the same Interface instance (Local Services) to send messages to other Interfaces, or to
broadcast messages to every Interface. The CINService is responsible for listening for, discovering, validating and
interpreting messages received from other Interfaces, and then passing on the validated and interpreted results to the
appropriate Local Services.
//TODO: Update this to include interface version in JSON
//TODO: RSA keys shouldn't be used to encrypt message payload. An AES key should be used instead, and then the AES key should be encrypted with the recipiants public key, and that should be included in JSON in some sort of "encrypted key" field
Local Services can request that a message be sent by calling the CINService's sendMessage method. When this sendMessage
method is called, the caller must pass a message object. The sendMessage method then generates a JSON string
representation of the message's data. Then the sendMessage method determines if the message is a Broadcast message which
may be read by all Interfaces, or if the message is a Direct message, which should only be read by a specific interface:
If the message object's recipientInterfaceID field is empty, CINService determines it is a Broadcast message. If the
message object's recipientInterfaceID field is not empty, CINService determines it is a Direct message. If the message
is a Broadcast message, then CINService creates a new JSON string with the following fields: "sender", "payload" and
"signature". CINService sets the "sender" field to the message object's senderInterfaceID field, and the "payload" field
to the JSON string representation of the message's data. Then CINService obtains the private key associated with the
message object's senderInterfaceID field, generates a hash of the JSON string representation of the message's data,
signs this hash with the obtained private key, and sets the "signature" field to this resulting signature. Then
CINService sends this message in the Commuto Interface Network Matrix room. If the message is a Direct message, then
CINService creates a new JSON string with the following fields: "sender", "recipient", "payload" and "signature".
CINService sets the "sender" field to the message object's senderInterfaceID field, and the recipient field to the
message object's recipientInterfaceID field. Then CINService obtains the public key associated with the message object's
recipientInterfaceID field, uses it to encrypt the JSON string representation of the message object's data, and then
sets the "payload" field to the result. Then CINService obtains the private key associated with the message object's
senderInterfaceID field, generates a hash of the JSON string representation of the message's data, signs this hash with
the obtained private key, and sets the "signature" field to this resulting signature. Then CINService sends this message
in the Commuto Interface Network Matrix room.
By default, CINService does not listen for messages in the Commuto Interface Network Matrix room. Local Services can
request that CINService listen for specific messages by calling the CINService's expectMessage method. When this
expectMessage method is called, the caller must pass a MessageExpectation object. This MessageExpectation object is then
added to CINService's list of active MessageExpectation objects. A MessageExpectation object describes the attributes of
messages for which CINService should search, and also specifies which Local Service should receive validated,
interpreted messages with attributes matching those specified in the MessageExpectation object, when the CINService
discovers such messages. When one or more MessageExpectations is/are active, CINService compares each new message in the
Commuto Interface Network Matrix room with each MessageExpectation object in CINService's list of active
MessageExpectation objects. If a message matches a MessageExpectation, then CINService, after validating the message and
decrypting it as necessary, passes it to the Local Service specified in the MessageExpectation. If a message does not
match any MessageExpectations, it is dropped. MessageExpectations specify certain message fields, and for each specified
message field, a MessageExpectation specifies possible values for that particular message field. These possible values
are known as patterns. In addition to arbitrary text strings, there are three special pattern values: Present, which
expresses a requirement that a message contains a certain field and a value for that field, though the actual value
itself is not considered. Empty, which expresses a requirement that a message contains a certain field and no value for
that field (the field is empty). Not_Present, which expresses a requirement that a message does not contain a certain
field. CINService determines that a message matches a MessageExpectation in the following manner: For each message field
specified in the MessageExpectation object, that field must be present in the message, unless the MessageExpectation
object specifies a Not_Present value for that field, in which case the field must not be present. The value of that
field must be empty if the MessageExpectation object specifies an Empty value for that field, or must have any value if
the MessageExpectation object specifies a Present value for that field, or otherwise must have a value equal to the
pattern specified for that value by the MessageExpectation object. If all of these conditions are met, then CINService
determines that the message matches the MessageExpectation and that the message is expected by the service that created
the MessageExpectation, and, after validating the message and decrypting it as necessary, passes it to the Local Service
specified in the Message. Once the Local Service has received the message, the Local Service evaluates it to determine
if it is a message that the Local Service is expecting. If the Local Service determines that it has received the message
it expected, it then requests that CINService stops listening for such messages by calling the CINService's
removeMessageExpectation method. To call this method, the calling Local Service must create and pass to the method a
MessageExpectation identical to the MessageExpectation the Local Service created earlier, describing the attributes of
the message that the Local Service was expecting but now has received. Then, CINService searches through its list of
active MessageExpectations, and removes any that are identical to the MessageExpectation passed to the
removeMessageExpectation method.
//TODO: create one big, META ME, such that if a packet matches any current MEs, they match the meta ME, then have the Matrix Homeserver filter the messages it serves using this ME. Though this has to happen at the Matrix Homeserver level, so it will have to be a seperate thing
By default, CINService attempts to validate every message before carrying out any other processing. Public Key
Announcement messages are validated slightly differently than all other types of messages. The user may optionally
configure CINService to skip message validation on Broadcast messages. In order to validate a message that is not a
Public Key Announcement message, CINService obtains the public key associated with the message's senderInterfaceID,
generates a hash of the value in the message's "payload" field, and then uses the obtained public key to verify that the
signature in the message's "signature" field is a valid signature of the hash of the "payload" data. If the signature is
valid, CINService continues processing the message. Otherwise, CINService drops the message. In order to validate a
Public Key Announcement message, CINService notes the new public key included in the message's "payload" field,
generates a hash of the value in the message's "payload" field, and then uses the noted public key to verify that the
signature in the message's "signature" field is a valid signature of the hash of the "payload" data. If the signature is
valid, CINService continues processing the Public Key Announcement message. Otherwise, CINService drops the message.
Before CINService can analyze the payload of a Direct message, it must first decrypt the payload. To do this, CINService
obtains the private key associated with the value in the message's recipientInterfaceID field, decrypts the payload
using this private key, and carries on its analysis of the message. If the attempt to obtain the key fails or decryption
fails, CINService drops the message.
CINService receives and parses messages in JSON string format. When CINService has determined that a message is expected
by a Local Service, CINService creates a message object with the JSON string's data and passes that message object to
the proper Local Service.
A Local Service can cause CINService to actively search for old messages matching one or more MessageExpectations by
calling CINService's expectOldMessage method. To do this, a Local Service must specify: either a date/time interval or a
single date/time, and either a single MessageExpectation or a list of MessageExpectations. If a Local Service specifies
a date/time interval, then CINService searches for messages matching the passed MessageExpectation(s) within all
messages sent in the Commuto Interface Network Matrix room within the specified date/time interval. If a Local Service
specifies only a single date/time, then CINService searches for messages matching the passed MessageExpectation(s)
within all messages sent in the Commuto Interface Network Matrix room beginning at the specified date/time and up to and
including the most recent message. If a Local Service passes a single MessageExpectation, then CINService will pass all
messages matching the MessageExpectation to the Local Service specified in the MessageExpectation. If a Local Service
passes a list of MessageExpectations, then CINService will compare each message to each MessageExpectation, and will
pass all messages matching a MessageExpectation to the Local Service specified in the MessageExpectation.
Upon Interface shutdown, CINService persistently stores the timestamp at which the last message that CINService
processed was sent. Upon Interface startup, CINService waits for a signal from every Local Service indicating that the
Local Service is properly initialized, and has passed to CINService all necessary MessageExpectations. When such a
signal has been received from every Local Service, CINService searches for messages matching all active
MessageExpectations within all messages sent in the Commuto Interface Network Matrix room since the time described by
the timestamp of the last-processed message before the Interface's most recent shutdown.

Commuto Interface Key Manager Service Specification:
The Interface shall have a KMService instance. The KMService is responsible for generating key pairs and their
accompanying Interface ID, storing the Interface's own key pairs along with each pair's corresponding Interface ID,
validating and storing other Interfaces' public keys along with each key's corresponding Interface ID, and serving
the Interface's own key pairs and other Interface's public keys to other Local Services on demand, given an Interface
ID.
An Interface ID is a SHA-256 hash of an Interface's RSA public key in PKCS#1 byte encoded format. Interfaces may have
more than one Interface ID, since a new key pair and Interface ID is created for every swap offer. A Local Service can
request that KMService generate a new key pair and Interface ID by calling KMService's key generation method:
generateKeyPair()
    Generates a new 2048-bit RSA key pair and derives the Interface ID by taking the SHA-256 hash of the
    new public key in PKCS#1 byte encoded format. Computes the Base64 string encoded PKCS#1 representations of the
    newly generated public and private keys and the Base64 string representation of the derived Interface ID and
    persistently stores them using DBService.storeKeyPair. Returns the Interface ID, public key and private key to the
    caller.
A Local Service can request its Interface's own key pairs from KMService by calling KMService's method:
getKeyPair(interfaceId)
    where interfaceId is the SHA-256 hash of the desired key pair's public key in PKCS#1 byte encoded format. Computes
    the Base64 string representation of interfaceId and retrieves the key pair in Base64 string encoded PKCS#1 format by
    passing the resulting representation of interfaceId to DBService.getKeyPair. Recreates public and private key
    objects using the strings returned by DBService.getKeyPair. Returns interfaceId, public key and private key to the
    caller.
A Local Service can request that KMService stores an Interface's public key by calling KMService's method:
storePublicKey(pubKey)
    where pubKey is a public key object. Derives the Interface ID by taking the SHA-256 hash of pubKey in PKCS#1 byte
    encoded format. Computes the Base64 string encoded PKCS#1 representation of pubKey and the Base64 string
    representation of the derived Interface ID and persistently stores them using DBService.storePublicKey.
A Local Service can request other Interfaces' public keys from KMService by calling KMService's method:
getPublicKey(interfaceId)
    where interfaceId is the SHA-256 hash of the desired public key in PKCS#1 byte encoded format. Computes the Base64
    string representation of interfaceId and retrieves the public key in Base64 string encoded PKCS#1 format by passing
    the resulting representation of interfaceId to DBService.getPublicKey. Recreates the public key object using the
    string returned by DBService.getPublicKey. Returns interfaceId and the public key to the caller.

Commuto Interface Database Service Specification
The Interface shall have a DBService instance. The DBService is responsible for persistently storing the Interface's
data, serving this data to Local Services upon request, and accepting Local Services' requests to add and remove data
from storage.
The DBService shall have the following functions exclusively for use by KMService:
storeKeyPair(interfaceId, publicKey, privateKey)
    Associates publicKey and privateKey with interfaceId and stores them in the Interface's SQL database.
getKeyPair(interfaceId)
    Searches the Interface's SQL database for a key pair associated with the supplied value of interfaceId. Throws an
    error if more than one key pair is found. Returns interfaceId, public key and private key if one key pair is found.
    Returns nothing if no key pair is found.
storePublicKey(interfaceId, publicKey)
    Associates publicKey with interfaceId and stores them in the Interface's SQL database.
getPublicKey(interfaceId)
    Searches the Interface's SQL database for a public key associated with the supplied value of interfaceId. Throws an
    error if more than one public key is found. Returns interfaceId and public key if a public key is found. Returns
    nothing if no public key is found.
where interfaceId, publicKey and privateKey are strings.


Needs to:
For CINService:
Store Matrix Credentials
For KMService:
Store own private + public key pairs along with their interface ID
Serve these upon request
Add new upon request
Store other public keys along with their interface ID
Serve these upon request
Add new upon request
For Open Offer Service (not yet designed):
Add/Remove Open Offers
Handle pending taken-by-own-interface offers
For Swaps Service (not yet designed):
Add Taken Swaps
Associate chat messages with taken swaps
Associate payment method info with taken swaps