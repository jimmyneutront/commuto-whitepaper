Commuto Interface Specification
Version 0.2 [DRAFT]

The Commuto Interface allows easy interaction with the core Commuto Protocol contract functionality. Commuto Interface
instances use the Matrix network to exchange offer information, chat messages, and other important data with each other,
composing the Commuto Interface Network. This document describes the official Commuto Interface specification.
Henceforth, "the Interface" refers to the Commuto Interface reference implementation described by this document.

The term "key object" refers to a platform-specific object representing a cryptographic key, such as SecKey on iOS or
java.security.PublicKey on Android or JVM. An asymmetric key said to be in "byte format" is a byte array containing
the key encoded as bytes according to the PKCS#1 standard. A symmetric key said to be in "byte format" is a byte array
containing the key encoded as bytes. A key said to be in "string format" is the Base64 string representation of a key in
byte format.

message JSON fields:
sender
payload
signature
recipient

Interface Interaction with Commuto Protocol:
//TODO: Don't discard message if "msgType" doesn't match, because it could be a chat message
//TODO: Update spec with updated message handling logic
//TODO: Update spec to reflect storage of local offer/swap before waiting for OpenOffer/TakeOffer event emission
//TODO: Clarify storage and retrieval of payment method details in local database
//TODO: Deal with tx reverts
//TODO: Include TXID in public key announcement
The following is a description of how Interfaces will interact with each other and with the on-chain Commuto Protocol as
described in the whitepaper in order to execute swaps. The symbols FIAT and STBL as well as the terms "buyer" and
"seller" have the same meaning in this description as they do in the Commuto Protocol whitepaper.
The following is depicted in the Business Process Model Notation diagrams found in this repo.
Phase 1:
The taker begins listening to the blockchain for the emission of OfferOpened events.
The maker generates a new 2048-bit RSA key pair and a new UUID. The maker prepares an EVM compatible Offer object to be
passed to the Commuto Protocol's newOffer function. The maker sets the Offer object's interfaceId property to the
SHA-256 hash of the public key in byte format of the newly generated key pair. The maker specifies the offer's price in
UTF-8 byte format and sets the Offer object's price property equal to the result. The maker specifies the settlement
methods to be used in UTF-8 bytes and sets the Offer object's settlementMethods property to an array of the results.
The maker creates a JSON string containing their payment details with the following structure:
{
"paymentDetails":[details about maker's particular fiat payment accounts to be used, like a cashtag or bank account
information. The maker supplies one set of payment details for each supported payment method.]
}
The maker calls the Commuto Protocol's newOffer function, passing the UUID and EVM compatible Offer object and locking
the security deposit and maximum service fee in escrow. The maker begins listening to the blockchain for the emission of
the OfferOpened event corresponding to their newly opened offer. The maker creates a local offer object with all the
information specified in their EVM compatible Offer object as well as the payment details string, sets the offer
object's status property to "newOfferTxPublished" and stores this object locally. When the maker detects the emission of
the OfferOpened event corresponding to their newly opened offer, they set the offer object's status to
"awaitingPKAnnouncement" and create the following two JSON strings:
(the message JSON string)
{
"sender":[the interface id used in offer creation as Base64-string-encoded bytes],
"msgType":"pka", (pka -> public key announcement)
"payload": null,
"signature":null
}
and (the payload JSON string)
{
"pubKey":[the public key from which the interface id used was derived in string format]
"offerId":[the UUID of the newly created offer in Base64-encoded string format]
}.
The maker converts the payload JSON string to UTF-8 bytes, creates a Base64-encoded string from those bytes, and sets
the "payload" field in the first string equal to the result. Then the maker calculates the SHA-256 hash of the JSON
string's UTF-8 byte representation, signs it with their private key, and sets the "signature" field in the first string
equal to the Base64-encoded string representation of the signature. Then the maker sends the first string as a message
in the Commuto Interface Network (CIN) Matrix room. When the message is successfully sent, the maker updates the offer's
status to "offerOpened". The maker begins listening to the blockchain for the emission of an OfferTaken event
corresponding to their open offer. When the maker detects the emission of the OfferTaken event corresponding to their
offer, they call the Commuto Protocol's getSwap function and pass the id of the newly-taken offer to get the new swap
object.
When the taker detects the emission of the maker's OfferOpened event, they begin listening to the CIN Matrix room for a
message in JSON string format with the "msgType" field equal to "pka" and the "sender" field equal to the interfaceId
specified in the emitted OpenOffer event. If the taker finds such a message, they create a byte array from the
Base64-encoded string in the message's "payload" field, and then attempt to restore the payload JSON from the byte
array. If restoration fails, the taker discards the message and continues to listen for a valid message. If restoration
succeeds, the taker creates a byte array from the Base64-encoded string in the payload's "offerId" field and compares it
to the offer id specified in the emitted OfferOpened event. If byte array creation fails or the two do not match, the
taker discards the message and continues to listen for a valid message. If the two do match, the taker creates a public
key from the Base64-encoded string in the payload's "pubKey" field, creates a byte array from the Base64-encoded string
in the message's "sender" field, and then compares the interface id of the public key to the byte array. If the two do
not match, the taker discards the message and continues to listen for a valid message. If the two do match, the taker
restores the signature byte array from the Base64-encoded string in the "signature" field and attempts to verify the
signature using this byte array, the created public key, and the SHA-256 hash of the payload byte array. If signature
verification fails, the taker discards the message and continues to listen for a valid message. If signature
verification succeeds, the taker has confirmed that the key contained in the message is the maker's public key, and so
the taker associates the maker's public key with the maker's interface id and stores them locally.
The taker calls the Commuto Protocol's getOffer function and passes the offer id specified in the public key
announcement message, to get the terms of the offer. The taker decides to take the offer and prepares an EVM compatible
Swap object corresponding to the previously obtained Solidity Offer object, generating and storing a new 2048-bit RSA
key pair and deriving the key pair's corresponding interface id, the SHA-256 hash of the new public key in byte format.
The taker prepares a JSON string containing their payment details with the following structure:
{
"paymentDetails":[details about taker's particular fiat payment account to be used, like a cashtag or bank account
information, which correspond to the payment method that the taker has specified in their Swap object]
}
The taker calls the Commuto Protocol's takeOffer function, passing the UUID of the offer to be taken and the EVM
compatible Swap object and locking the required amount of STBL in escrow. If the taker is the buyer, this locks the
taker's security deposit and service fee in escrow; if the taker is the seller, this locks the taker's security deposit,
service fee and the swap amount in escrow. The taker begins listening to the blockchain for the emission of the
OfferTaken event corresponding to the newly taken swap. The taker creates a swap object with all the information
specified in their EVM compatible Swap object as well as the payment details string, sets the swap object's status
property to "takeOfferTxPublished" and stores this object locally. When the taker detects the emission of the OfferTaken
event corresponding to the new swap, they set the swap object's status to "awaitingTakerInfoAnnouncement" and create the
following two JSON strings:
(the message JSON string)
{
"sender":[the taker's newly created interface id as specified in their Swap object as a Base64 string],
"recipient":[the maker's interface id as a Base64 string],
"encryptedKey":null,
"encryptedIV":null,
"payload":null,
"signature":null
}
and (the payload JSON string)
{
"msgType":"takerInfo"
"pubKey":[the public key from which the interface id in the "sender" field was derived in string format],
"swapId":[the UUID of the newly taken swap in Base64-encoded string format],
"paymentDetails":null
}
The taker converts the value in the "paymentDetails" field of their payment details JSON string to UTF-8 bytes, creates
a Base-64 encoded string from those bytes, and sets the "paymentDetails" field in the payload JSON string equal to the
result. Then the taker converts the payload JSON string to a UTF-8 byte array, generates a new AES-256 key and
128 bit initialization vector, encrypts the byte array with the new key and initialization vector, and sets the
"payload" field in the message string equal to the Base64-encoded string representation of the encrypted byte array.
Then the taker calculates the SHA-256 hash of the encrypted byte array, signs it with their private key, and sets the
"signature" field in the first string equal to the Base64-encoded string representation of the signature. Then the taker
encrypts the AES-256 key and initialization vector using the maker's public key, and sets the "encryptedKey" and
"encryptedIV" fields in the message JSON string to the respective Base64 string encoded results. Then the taker sends
the first string as a message in the CIN Matrix room.
The taker begins listening to the CIN Matrix room for a message in JSON string format with the "sender" field equal to
the maker's interface id and the "recipient" field equal to the taker's interface id.
When the maker detects the OfferTaken event corresponding to their offer, they transform their local offer object to a
swap object and set its status to "awaitingTakerInfo" and begin listening to the CIN Matrix room for a message with the
"sender" field equal to the taker's interface id as specified in the emitted OfferTaken event, and the "recipient" field
equal to the maker's interface id. If the maker finds such a message, they create byte arrays from the Base64-encoded
strings in the message's "encryptedKey" and "encryptedIV" fields. If byte array creation fails, the maker discards the
message and continues to listen for a valid message. If byte array creation succeeds, the maker retrieves the private
key associated with the interface id in the message's "recipient" field and attempts to decrypt the encrypted key and
initialization vector byte arrays. If decryption fails, the maker discards the message and continues listening for a
valid message. If decryption succeeds, the maker creates a byte array from the Base64-encoded string in the message's
"payload" field and attempts to decrypt it using the decrypted key and initialization vector. If byte array creation or
payload decryption fails, the maker discards the message and continues listening for a valid message. If byte array
creation and decryption succeeds, the maker attempts to restore the payload JSON from the decrypted byte array. If
restoration fails, the maker discards the message and continues to listen for a valid message. If restoration succeeds,
the maker ensures that the payload's "msgType" field equals "takerInfo". If it does not, the maker discards the message
and continues listening for a valid message. If it does, the maker creates a byte array from the Base64-encoded string
in the payload's "swapId" field and compares it to the swap id specified in the emitted OfferTaken event. If byte array
creation fails or the two do not match, the maker discards the message and continues to listen for a valid message. If
the two do match, the maker attempts to create a public key from the Base64-encoded string in the payload's "pubKey"
field and create a byte array from the Base64-encoded string in the message's "sender" field. If public key or byte
array creation fails, the maker discards the message and continues listening for a valid message. If public key and byte
array creation succeed, the maker compares the interface id of the public key to the byte array. If the two do not
match, the maker discards the message and continues to listen for a valid message. If the two do match, the maker
restores the signature byte array from the Base-64 encoded string in the "signature" field and attempts to verify using
this byte array, the created public key, and the SHA-256 hash of the encrypted payload byte array. If signature
verification fails, the maker discards the message and continues to listen for a valid message. If signature
verification succeeds, the maker creates a byte array from the Base64-encoded string in the payload's "paymentDetails"
field and attempts to restore the payment details JSON from the byte array. If byte array creation or JSON restoration
fails, the maker discards the message and continues to listen for a valid message. If byte array creation and JSON
restoration succeed, the maker checks that the payment details correspond to the payment method that the taker chose
when taking the offer. If they do not match, the maker discards the message and continues to listen for a valid message.
If they do match, the maker has confirmed that the key contained in the message is the taker's public key, and that the
payment details contained in the message were supplied by the taker and are valid, and so the maker associates the
taker's public key with the taker's interface id and stores them locally, and stores the taker's payment details locally
as well.
The maker then sets the status of their local swap object to "receivedTakerInfo" and prepares the following two JSON
strings:
(the message JSON string)
{
"sender":[the maker's interface id as a Base64 string]
"recipient":[the taker's interface id as a Base64 string]
"encryptedKey": null,
"encryptedIV": null,
"payload": null,
"signature": null
}
and (the payload JSON string)
{
"msgType":"takerInfo"
"swapId":[the UUID of the swap in Base64-encoded string format]
"paymentDetails":null
}
The maker converts the value from the "paymentDetails" field of their payment details JSON string to UTF-8 bytes,
creates a Base-64 encoded string from those bytes, and sets the "paymentDetails" field in the payload JSON string equal
to the result. Then the maker converts the payload JSON string into a UTF-8 byte array, generates a new AES-256 key and
128 bit initialization vector, encrypts the byte array with the new key and initialization vector, and sets the
"payload" field in the message string equal to the Base64-encoded string representation of the encrypted byte array.
Then the maker calculates the SHA-256 hash of the encrypted byte array, signs it with their private key, and sets the
"signature" field in the message string equal to the Base64-encoded string representation of the signature. Then the
maker encrypts the AES-256 key and initialization vector using the taker's public key, and sets the "encryptedKey" and
"encryptedIV" fields in the message JSON string to the respective Base64-encoded string results. Then the maker sends
the string as a message in the CIN Matrix room.
When the taker detects a message in the CIN Matrix room with the "sender" field equal to the maker's interface id and
the "recipient" field equal to the taker's id, the taker attempts to create the encrypted payload byte array from the
Base-64 encoded string in the message's "payload" field. If byte array creation fails, the taker discards the message
and continues listening for another valid message. If byte array creation succeeds, the taker attempts to restore the
signature byte array from the Base-64 encoded string in the "signature" field. If byte array restoration fails, the
taker discards the message and continues listening for another valid message. If byte array restoration succeeds, the
taker retrieves the maker's public key, calculates the SHA-256 hash of the encrypted payload byte array to obtain the
signed data, and then attempts to verify the message's signature. If signature verification fails, the taker discards
the message and continues to listen for a valid message. If signature verification succeeds, the taker creates byte
arrays from the Base64-encoded strings in the message's "encryptedKey" and "encryptedIV" fields. If byte array creation
fails, the taker discards the message and continues to listen for a valid message. If byte array creation succeeds, the
taker retrieves the private key associated with the interface id in the message's "recipient" field (which is the
maker's interface id) and attempts to decrypt the encrypted key and initialization vector byte arrays. If decryption
fails, the taker discards the message and continues listening for a valid message. If decryption succeeds, the taker
creates a byte array from the Base64-encoded string in the message's "payload" and attempts to decrypt it using the
decrypted key and initialization vector. If byte array creation or payload decryption fails, the taker discards the
message and continues listening for a valid message. If byte array creation and decryption succeeds, the taker attempts
to restore the payload JSON from the decrypted byte array. If restoration fails, the taker discards the message and
continues to listen for a valid message. If restoration succeeds, the taker ensures that the payload's "msgType" field
equals "makerInfo". If it does not, the taker discards the message and continues listening for a valid message. If it
does, the taker creates a byte array from the Base64-encoded string in the payload's "swapId" field and compares it to
the swap id specified in the emitted OfferTaken event. If byte array creation fails or the two do not match, the taker
discards the message and continues to listen for a valid message. If the two do match, the taker creates a byte array
from the Base64-encoded string in the payload's "paymentDetails" field and attempts to restore the payment details JSON
from the byte array. If byte array creation or JSON restoration fails, the taker discards the message and continues to
listen for a valid message. If byte array creation and JSON restoration succeed, the taker checks that the payment
details correspond to the payment method that the taker chose when taking the offer. If they do not match, the taker
discards the message and continues to listen for a valid message. If they do match, the taker has confirmed that the
payment details contained in the message supplied by the maker are valid, and so the taker stores the maker's payment
details locally.
Then the taker sets the status of their local swap object to "receivedMakerInfo".
If the swap is a maker-as-seller swap, both the maker and the taker begin to listen for the emission of a SwapFilled
event corresponding to their swap. Then the maker-as-seller calls Commuto Protocol's fillSwap function, passing the UUID
of the swap and locking the swap amount of STBL in escrow. Once the maker and taker detect the emission of the
SwapFilled event corresponding to their maker-as-seller swap, they both update the status of their local swap objects to
"makerAsSellerDepositLocked".
Phase 2:
The buyer and seller both begin to listen for the emission of a PaymentSent event corresponding to their swap.
The buyer sends fiat payment to the seller using the previously agreed-upon payment method and details and in the
agreed-upon fiat currency denomination, and calls the Commuto Protocol's reportPaymentSent function and passes the UUID
of the swap. Once the buyer and seller detect the emission of the PaymentSent event corresponding to their swap, they
both update the status of their local swap objects to "paymentSent".
The buyer and seller both begin to listen for the emission of a PaymentReceived event corresponding to their swap.
Once the seller receives fiat payment, they call the reportPaymentReceived function, passing the UUID of the swap. Once
the buyer and seller detect the emission of the PaymentReceived event corresponding to their swap, they both update the
status of their local swap objects to "paymentReceived".
The buyer and seller both call the Commuto Protocol's closeSwap function in order to receive their STBL. When the buyer
detects the emission of a BuyerClosed event corresponding to the swap, the buyer marks their local swap object as
"closed". When the seller detects the emission of a SellerClosed event corresponding to the swap, the seller marks their
local swap object as "closed".

Commuto Interface Network Specification:
//TODO: Eventually, each Interface should have its own Matrix homeserver built in, to regularly create "throwaway" accounts
//TODO: Clarify interactions with KMService
The Interface shall have a CINService instance. The CINService is responsible for receiving and acting on requests from
other services belonging to the same Interface instance (Local Services) to send messages to other Interfaces, or to
broadcast messages to every Interface. The CINService is responsible for listening for, discovering, validating and
interpreting messages received from other Interfaces, and then passing on the validated and interpreted results to the
appropriate Local Services.
//TODO: Update this to include interface version in JSON
//TODO: RSA keys shouldn't be used to encrypt message payload. An AES key should be used instead, and then the AES key should be encrypted with the recipiants public key, and that should be included in JSON in some sort of "encrypted key" field
Local Services can request that a message be sent by calling the CINService's sendMessage method. When this sendMessage
method is called, the caller must pass a message object. The sendMessage method then generates a JSON string
representation of the message's data. Then the sendMessage method determines if the message is a Broadcast message which
may be read by all Interfaces, or if the message is a Direct message, which should only be read by a specific interface:
If the message object's recipientInterfaceID field is empty, CINService determines it is a Broadcast message. If the
message object's recipientInterfaceID field is not empty, CINService determines it is a Direct message. If the message
is a Broadcast message, then CINService creates a new JSON string with the following fields: "sender", "payload" and
"signature". CINService sets the "sender" field to the message object's senderInterfaceID field, and the "payload" field
to the JSON string representation of the message's data. Then CINService obtains the private key associated with the
message object's senderInterfaceID field, generates a hash of the JSON string representation of the message's data,
signs this hash with the obtained private key, and sets the "signature" field to this resulting signature. Then
CINService sends this message in the Commuto Interface Network Matrix room. If the message is a Direct message, then
CINService creates a new JSON string with the following fields: "sender", "recipient", "payload" and "signature".
CINService sets the "sender" field to the message object's senderInterfaceID field, and the recipient field to the
message object's recipientInterfaceID field. Then CINService obtains the public key associated with the message object's
recipientInterfaceID field, uses it to encrypt the JSON string representation of the message object's data, and then
sets the "payload" field to the result. Then CINService obtains the private key associated with the message object's
senderInterfaceID field, generates a hash of the JSON string representation of the message's data, signs this hash with
the obtained private key, and sets the "signature" field to this resulting signature. Then CINService sends this message
in the Commuto Interface Network Matrix room.
By default, CINService does not listen for messages in the Commuto Interface Network Matrix room. Local Services can
request that CINService listen for specific messages by calling the CINService's expectMessage method. When this
expectMessage method is called, the caller must pass a MessageExpectation object. This MessageExpectation object is then
added to CINService's list of active MessageExpectation objects. A MessageExpectation object describes the attributes of
messages for which CINService should search, and also specifies which Local Service should receive validated,
interpreted messages with attributes matching those specified in the MessageExpectation object, when the CINService
discovers such messages. When one or more MessageExpectations is/are active, CINService compares each new message in the
Commuto Interface Network Matrix room with each MessageExpectation object in CINService's list of active
MessageExpectation objects. If a message matches a MessageExpectation, then CINService, after validating the message and
decrypting it as necessary, passes it to the Local Service specified in the MessageExpectation. If a message does not
match any MessageExpectations, it is dropped. MessageExpectations specify certain message fields, and for each specified
message field, a MessageExpectation specifies possible values for that particular message field. These possible values
are known as patterns. In addition to arbitrary text strings, there are three special pattern values: Present, which
expresses a requirement that a message contains a certain field and a value for that field, though the actual value
itself is not considered. Empty, which expresses a requirement that a message contains a certain field and no value for
that field (the field is empty). Not_Present, which expresses a requirement that a message does not contain a certain
field. CINService determines that a message matches a MessageExpectation in the following manner: For each message field
specified in the MessageExpectation object, that field must be present in the message, unless the MessageExpectation
object specifies a Not_Present value for that field, in which case the field must not be present. The value of that
field must be empty if the MessageExpectation object specifies an Empty value for that field, or must have any value if
the MessageExpectation object specifies a Present value for that field, or otherwise must have a value equal to the
pattern specified for that value by the MessageExpectation object. If all of these conditions are met, then CINService
determines that the message matches the MessageExpectation and that the message is expected by the service that created
the MessageExpectation, and, after validating the message and decrypting it as necessary, passes it to the Local Service
specified in the Message. Once the Local Service has received the message, the Local Service evaluates it to determine
if it is a message that the Local Service is expecting. If the Local Service determines that it has received the message
it expected, it then requests that CINService stops listening for such messages by calling the CINService's
removeMessageExpectation method. To call this method, the calling Local Service must create and pass to the method a
MessageExpectation identical to the MessageExpectation the Local Service created earlier, describing the attributes of
the message that the Local Service was expecting but now has received. Then, CINService searches through its list of
active MessageExpectations, and removes any that are identical to the MessageExpectation passed to the
removeMessageExpectation method.
//TODO: create one big, META ME, such that if a packet matches any current MEs, they match the meta ME, then have the Matrix Homeserver filter the messages it serves using this ME. Though this has to happen at the Matrix Homeserver level, so it will have to be a seperate thing
By default, CINService attempts to validate every message before carrying out any other processing. Public Key
Announcement messages are validated slightly differently than all other types of messages. The user may optionally
configure CINService to skip message validation on Broadcast messages. In order to validate a message that is not a
Public Key Announcement message, CINService obtains the public key associated with the message's senderInterfaceID,
generates a hash of the value in the message's "payload" field, and then uses the obtained public key to verify that the
signature in the message's "signature" field is a valid signature of the hash of the "payload" data. If the signature is
valid, CINService continues processing the message. Otherwise, CINService drops the message. In order to validate a
Public Key Announcement message, CINService notes the new public key included in the message's "payload" field,
generates a hash of the value in the message's "payload" field, and then uses the noted public key to verify that the
signature in the message's "signature" field is a valid signature of the hash of the "payload" data. If the signature is
valid, CINService continues processing the Public Key Announcement message. Otherwise, CINService drops the message.
Before CINService can analyze the payload of a Direct message, it must first decrypt the payload. To do this, CINService
obtains the private key associated with the value in the message's recipientInterfaceID field, decrypts the payload
using this private key, and carries on its analysis of the message. If the attempt to obtain the key fails or decryption
fails, CINService drops the message.
CINService receives and parses messages in JSON string format. When CINService has determined that a message is expected
by a Local Service, CINService creates a message object with the JSON string's data and passes that message object to
the proper Local Service.
A Local Service can cause CINService to actively search for old messages matching one or more MessageExpectations by
calling CINService's expectOldMessage method. To do this, a Local Service must specify: either a date/time interval or a
single date/time, and either a single MessageExpectation or a list of MessageExpectations. If a Local Service specifies
a date/time interval, then CINService searches for messages matching the passed MessageExpectation(s) within all
messages sent in the Commuto Interface Network Matrix room within the specified date/time interval. If a Local Service
specifies only a single date/time, then CINService searches for messages matching the passed MessageExpectation(s)
within all messages sent in the Commuto Interface Network Matrix room beginning at the specified date/time and up to and
including the most recent message. If a Local Service passes a single MessageExpectation, then CINService will pass all
messages matching the MessageExpectation to the Local Service specified in the MessageExpectation. If a Local Service
passes a list of MessageExpectations, then CINService will compare each message to each MessageExpectation, and will
pass all messages matching a MessageExpectation to the Local Service specified in the MessageExpectation.
Upon Interface shutdown, CINService persistently stores the timestamp at which the last message that CINService
processed was sent. Upon Interface startup, CINService waits for a signal from every Local Service indicating that the
Local Service is properly initialized, and has passed to CINService all necessary MessageExpectations. When such a
signal has been received from every Local Service, CINService searches for messages matching all active
MessageExpectations within all messages sent in the Commuto Interface Network Matrix room since the time described by
the timestamp of the last-processed message before the Interface's most recent shutdown.

Commuto Interface Key Manager Service Specification:
The Interface shall have a KMService instance. The KMService is responsible for generating key pairs and their
accompanying Interface ID, storing the Interface's own key pairs along with each pair's corresponding Interface ID,
validating and storing other Interfaces' public keys along with each key's corresponding Interface ID, and serving
the Interface's own key pairs and other Interface's public keys to other Local Services on demand, given an Interface
ID.
An Interface ID is a SHA-256 hash of an Interface's RSA public key in PKCS#1 byte encoded format. Interfaces may have
more than one Interface ID, since a new key pair and Interface ID is created for every swap offer. A Local Service can
request that KMService generate a new key pair and Interface ID by calling KMService's key generation method:
generateKeyPair()
    Generates a new 2048-bit RSA key pair and derives the Interface ID by taking the SHA-256 hash of the
    new public key in PKCS#1 byte encoded format. Computes the Base64 string encoded PKCS#1 representations of the
    newly generated public and private keys and the Base64 string representation of the derived Interface ID and
    persistently stores them using DBService.storeKeyPair. Returns the Interface ID, public key and private key to the
    caller.
A Local Service can request its Interface's own key pairs from KMService by calling KMService's method:
getKeyPair(interfaceId)
    where interfaceId is the SHA-256 hash of the desired key pair's public key in PKCS#1 byte encoded format. Computes
    the Base64 string representation of interfaceId and retrieves the key pair in Base64 string encoded PKCS#1 format by
    passing the resulting representation of interfaceId to DBService.getKeyPair. Recreates public and private key
    objects using the strings returned by DBService.getKeyPair. Returns interfaceId, public key and private key to the
    caller.
A Local Service can request that KMService stores an Interface's public key by calling KMService's method:
storePublicKey(pubKey)
    where pubKey is a public key object. Derives the Interface ID by taking the SHA-256 hash of pubKey in PKCS#1 byte
    encoded format. Computes the Base64 string encoded PKCS#1 representation of pubKey and the Base64 string
    representation of the derived Interface ID and persistently stores them using DBService.storePublicKey.
A Local Service can request other Interfaces' public keys from KMService by calling KMService's method:
getPublicKey(interfaceId)
    where interfaceId is the SHA-256 hash of the desired public key in PKCS#1 byte encoded format. Computes the Base64
    string representation of interfaceId and retrieves the public key in Base64 string encoded PKCS#1 format by passing
    the resulting representation of interfaceId to DBService.getPublicKey. Recreates the public key object using the
    string returned by DBService.getPublicKey. Returns interfaceId and the public key to the caller.

Commuto Interface Database Service Specification
The Interface shall have a DBService instance. The DBService is responsible for persistently storing the Interface's
data, serving this data to Local Services upon request, and accepting Local Services' requests to add and remove data
from storage.
The DBService shall have the following functions exclusively for use by KMService:
storeKeyPair(interfaceId, publicKey, privateKey)
    Associates publicKey and privateKey with interfaceId and stores them in the Interface's SQL database.
getKeyPair(interfaceId)
    Searches the Interface's SQL database for a key pair associated with the supplied value of interfaceId. Throws an
    error if more than one key pair is found. Returns interfaceId, public key and private key if one key pair is found.
    Returns nothing if no key pair is found.
storePublicKey(interfaceId, publicKey)
    Associates publicKey with interfaceId and stores them in the Interface's SQL database.
getPublicKey(interfaceId)
    Searches the Interface's SQL database for a public key associated with the supplied value of interfaceId. Throws an
    error if more than one public key is found. Returns interfaceId and public key if a public key is found. Returns
    nothing if no public key is found.
where interfaceId, publicKey and privateKey are strings.


Needs to:
For CINService:
Store Matrix Credentials
For KMService:
Store own private + public key pairs along with their interface ID
Serve these upon request
Add new upon request
Store other public keys along with their interface ID
Serve these upon request
Add new upon request
For Open Offer Service (not yet designed):
Add/Remove Open Offers
Handle pending taken-by-own-interface offers
For Swaps Service (not yet designed):
Add Taken Swaps
Associate chat messages with taken swaps
Associate payment method info with taken swaps