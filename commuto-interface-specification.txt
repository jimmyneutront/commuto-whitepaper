Commuto Interface Specification
Version 0.2 [DRAFT]

The Commuto Interface allows easy interaction with the core Commuto Protocol contract functionality. Commuto Interface
instances use the Matrix network to exchange offer information, chat messages, and other important data with each other,
composing the Commuto Interface Network. This document describes the official Commuto Interface specification.
Henceforth, "the Interface" refers to the Commuto Interface reference implementation described by this document.

The term "key object" refers to a platform-specific object representing a cryptographic key, such as SecKey on iOS or
java.security.PublicKey on Android or JVM. An asymmetric key said to be in "byte format" is a byte array containing
the key encoded as bytes according to the PKCS#1 standard. A symmetric key said to be in "byte format" is a byte array
containing the key encoded as bytes. A key said to be in "string format" is the Base64 string representation of a key in
byte format.

message JSON fields:
sender
payload
signature
recipient

Interface Interaction with Commuto Protocol:
//TODO: EVM compatible STRUCT, not OBJECT
//TODO: Don't discard message if "msgType" doesn't match, because it could be a chat message
//TODO: Update spec with updated message handling logic
//TODO: Update spec to reflect storage of local offer/swap before waiting for OpenOffer/TakeOffer event emission
//TODO: Clarify storage and retrieval of payment method details in local database
//TODO: Deal with tx reverts
//TODO: Include TXID in public key announcement
The following is a description of how Interfaces will interact with each other and with the on-chain Commuto Protocol as
described in the whitepaper in order to execute swaps. The symbols FIAT and STBL as well as the terms "buyer" and
"seller" have the same meaning in this description as they do in the Commuto Protocol whitepaper.
The following is depicted in the Business Process Model Notation diagrams found in this repo.
Phase 1:
The taker begins listening to the blockchain for the emission of OfferOpened events.
The maker generates a new 2048-bit RSA key pair and a new UUID. The maker prepares an EVM compatible Offer object to be
passed to the Commuto Protocol's newOffer function. The maker sets the Offer object's interfaceId property to the
SHA-256 hash of the public key in byte format of the newly generated key pair. The maker specifies the offer's price in
UTF-8 byte format and sets the Offer object's price property equal to the result. The maker specifies the settlement
methods to be used in UTF-8 bytes and sets the Offer object's settlementMethods property to an array of the results.
The maker creates a JSON string containing their payment details with the following structure:
{
"paymentDetails":[details about maker's particular fiat payment accounts to be used, like a cashtag or bank account
information. The maker supplies one set of payment details for each supported payment method.]
}
The maker calls the Commuto Protocol's newOffer function, passing the UUID and EVM compatible Offer object and locking
the security deposit and maximum service fee in escrow. The maker begins listening to the blockchain for the emission of
the OfferOpened event corresponding to their newly opened offer. The maker creates a local offer object with all the
information specified in their EVM compatible Offer object as well as the payment details string, sets the offer
object's status property to "newOfferTxPublished" and stores this object locally. When the maker detects the emission of
the OfferOpened event corresponding to their newly opened offer, they set the offer object's status to
"awaitingPKAnnouncement" and create the following two JSON strings:
(the message JSON string)
{
"sender":[the interface id used in offer creation as Base64-string-encoded bytes],
"msgType":"pka", (pka -> public key announcement)
"payload": null,
"signature":null
}
and (the payload JSON string)
{
"pubKey":[the public key from which the interface id used was derived in string format]
"offerId":[the UUID of the newly created offer in Base64-encoded string format]
}.
The maker converts the payload JSON string to UTF-8 bytes, creates a Base64-encoded string from those bytes, and sets
the "payload" field in the first string equal to the result. Then the maker calculates the SHA-256 hash of the JSON
string's UTF-8 byte representation, signs it with their private key, and sets the "signature" field in the first string
equal to the Base64-encoded string representation of the signature. Then the maker sends the first string as a message
in the Commuto Interface Network (CIN) Matrix room. When the message is successfully sent, the maker updates the offer's
status to "offerOpened". The maker begins listening to the blockchain for the emission of an OfferTaken event
corresponding to their open offer. When the maker detects the emission of the OfferTaken event corresponding to their
offer, they call the Commuto Protocol's getSwap function and pass the id of the newly-taken offer to get the new swap
object.
When the taker detects the emission of the maker's OfferOpened event, they begin listening to the CIN Matrix room for a
message in JSON string format with the "msgType" field equal to "pka" and the "sender" field equal to the interfaceId
specified in the emitted OpenOffer event. If the taker finds such a message, they create a byte array from the
Base64-encoded string in the message's "payload" field, and then attempt to restore the payload JSON from the byte
array. If restoration fails, the taker discards the message and continues to listen for a valid message. If restoration
succeeds, the taker creates a byte array from the Base64-encoded string in the payload's "offerId" field and compares it
to the offer id specified in the emitted OfferOpened event. If byte array creation fails or the two do not match, the
taker discards the message and continues to listen for a valid message. If the two do match, the taker creates a public
key from the Base64-encoded string in the payload's "pubKey" field, creates a byte array from the Base64-encoded string
in the message's "sender" field, and then compares the interface id of the public key to the byte array. If the two do
not match, the taker discards the message and continues to listen for a valid message. If the two do match, the taker
restores the signature byte array from the Base64-encoded string in the "signature" field and attempts to verify the
signature using this byte array, the created public key, and the SHA-256 hash of the payload byte array. If signature
verification fails, the taker discards the message and continues to listen for a valid message. If signature
verification succeeds, the taker has confirmed that the key contained in the message is the maker's public key, and so
the taker associates the maker's public key with the maker's interface id and stores them locally.
The taker calls the Commuto Protocol's getOffer function and passes the offer id specified in the public key
announcement message, to get the terms of the offer. The taker decides to take the offer and prepares an EVM compatible
Swap object corresponding to the previously obtained Solidity Offer object, generating and storing a new 2048-bit RSA
key pair and deriving the key pair's corresponding interface id, the SHA-256 hash of the new public key in byte format.
The taker prepares a JSON string containing their payment details with the following structure:
{
"paymentDetails":[details about taker's particular fiat payment account to be used, like a cashtag or bank account
information, which correspond to the payment method that the taker has specified in their Swap object]
}
The taker calls the Commuto Protocol's takeOffer function, passing the UUID of the offer to be taken and the EVM
compatible Swap object and locking the required amount of STBL in escrow. If the taker is the buyer, this locks the
taker's security deposit and service fee in escrow; if the taker is the seller, this locks the taker's security deposit,
service fee and the swap amount in escrow. The taker begins listening to the blockchain for the emission of the
OfferTaken event corresponding to the newly taken swap. The taker creates a swap object with all the information
specified in their EVM compatible Swap object as well as the payment details string, sets the swap object's status
property to "takeOfferTxPublished" and stores this object locally. When the taker detects the emission of the OfferTaken
event corresponding to the new swap, they set the swap object's status to "awaitingTakerInfoAnnouncement" and create the
following two JSON strings:
(the message JSON string)
{
"sender":[the taker's newly created interface id as specified in their Swap object as a Base64 string],
"recipient":[the maker's interface id as a Base64 string],
"encryptedKey":null,
"encryptedIV":null,
"payload":null,
"signature":null
}
and (the payload JSON string)
{
"msgType":"takerInfo"
"pubKey":[the public key from which the interface id in the "sender" field was derived in string format],
"swapId":[the UUID of the newly taken swap in Base64-encoded string format],
"paymentDetails":null
}
The taker converts the value in the "paymentDetails" field of their payment details JSON string to UTF-8 bytes, creates
a Base-64 encoded string from those bytes, and sets the "paymentDetails" field in the payload JSON string equal to the
result. Then the taker converts the payload JSON string to a UTF-8 byte array, generates a new AES-256 key and
128 bit initialization vector, encrypts the byte array with the new key and initialization vector, and sets the
"payload" field in the message string equal to the Base64-encoded string representation of the encrypted byte array.
Then the taker calculates the SHA-256 hash of the encrypted byte array, signs it with their private key, and sets the
"signature" field in the first string equal to the Base64-encoded string representation of the signature. Then the taker
encrypts the AES-256 key and initialization vector using the maker's public key, and sets the "encryptedKey" and
"encryptedIV" fields in the message JSON string to the respective Base64 string encoded results. Then the taker sends
the first string as a message in the CIN Matrix room.
The taker begins listening to the CIN Matrix room for a message in JSON string format with the "sender" field equal to
the maker's interface id and the "recipient" field equal to the taker's interface id.
When the maker detects the OfferTaken event corresponding to their offer, they transform their local offer object to a
swap object and set its status to "awaitingTakerInfo" and begin listening to the CIN Matrix room for a message with the
"sender" field equal to the taker's interface id as specified in the emitted OfferTaken event, and the "recipient" field
equal to the maker's interface id. If the maker finds such a message, they create byte arrays from the Base64-encoded
strings in the message's "encryptedKey" and "encryptedIV" fields. If byte array creation fails, the maker discards the
message and continues to listen for a valid message. If byte array creation succeeds, the maker retrieves the private
key associated with the interface id in the message's "recipient" field and attempts to decrypt the encrypted key and
initialization vector byte arrays. If decryption fails, the maker discards the message and continues listening for a
valid message. If decryption succeeds, the maker creates a byte array from the Base64-encoded string in the message's
"payload" field and attempts to decrypt it using the decrypted key and initialization vector. If byte array creation or
payload decryption fails, the maker discards the message and continues listening for a valid message. If byte array
creation and decryption succeeds, the maker attempts to restore the payload JSON from the decrypted byte array. If
restoration fails, the maker discards the message and continues to listen for a valid message. If restoration succeeds,
the maker ensures that the payload's "msgType" field equals "takerInfo". If it does not, the maker discards the message
and continues listening for a valid message. If it does, the maker creates a byte array from the Base64-encoded string
in the payload's "swapId" field and compares it to the swap id specified in the emitted OfferTaken event. If byte array
creation fails or the two do not match, the maker discards the message and continues to listen for a valid message. If
the two do match, the maker attempts to create a public key from the Base64-encoded string in the payload's "pubKey"
field and create a byte array from the Base64-encoded string in the message's "sender" field. If public key or byte
array creation fails, the maker discards the message and continues listening for a valid message. If public key and byte
array creation succeed, the maker compares the interface id of the public key to the byte array. If the two do not
match, the maker discards the message and continues to listen for a valid message. If the two do match, the maker
restores the signature byte array from the Base-64 encoded string in the "signature" field and attempts to verify using
this byte array, the created public key, and the SHA-256 hash of the encrypted payload byte array. If signature
verification fails, the maker discards the message and continues to listen for a valid message. If signature
verification succeeds, the maker creates a byte array from the Base64-encoded string in the payload's "paymentDetails"
field and attempts to restore the payment details JSON from the byte array. If byte array creation or JSON restoration
fails, the maker discards the message and continues to listen for a valid message. If byte array creation and JSON
restoration succeed, the maker checks that the payment details correspond to the payment method that the taker chose
when taking the offer. If they do not match, the maker discards the message and continues to listen for a valid message.
If they do match, the maker has confirmed that the key contained in the message is the taker's public key, and that the
payment details contained in the message were supplied by the taker and are valid, and so the maker associates the
taker's public key with the taker's interface id and stores them locally, and stores the taker's payment details locally
as well.
The maker then sets the status of their local swap object to "receivedTakerInfo" and prepares the following two JSON
strings:
(the message JSON string)
{
"sender":[the maker's interface id as a Base64 string]
"recipient":[the taker's interface id as a Base64 string]
"encryptedKey": null,
"encryptedIV": null,
"payload": null,
"signature": null
}
and (the payload JSON string)
{
"msgType":"takerInfo"
"swapId":[the UUID of the swap in Base64-encoded string format]
"paymentDetails":null
}
The maker converts the value from the "paymentDetails" field of their payment details JSON string to UTF-8 bytes,
creates a Base-64 encoded string from those bytes, and sets the "paymentDetails" field in the payload JSON string equal
to the result. Then the maker converts the payload JSON string into a UTF-8 byte array, generates a new AES-256 key and
128 bit initialization vector, encrypts the byte array with the new key and initialization vector, and sets the
"payload" field in the message string equal to the Base64-encoded string representation of the encrypted byte array.
Then the maker calculates the SHA-256 hash of the encrypted byte array, signs it with their private key, and sets the
"signature" field in the message string equal to the Base64-encoded string representation of the signature. Then the
maker encrypts the AES-256 key and initialization vector using the taker's public key, and sets the "encryptedKey" and
"encryptedIV" fields in the message JSON string to the respective Base64-encoded string results. Then the maker sends
the string as a message in the CIN Matrix room.
When the taker detects a message in the CIN Matrix room with the "sender" field equal to the maker's interface id and
the "recipient" field equal to the taker's id, the taker attempts to create the encrypted payload byte array from the
Base-64 encoded string in the message's "payload" field. If byte array creation fails, the taker discards the message
and continues listening for another valid message. If byte array creation succeeds, the taker attempts to restore the
signature byte array from the Base-64 encoded string in the "signature" field. If byte array restoration fails, the
taker discards the message and continues listening for another valid message. If byte array restoration succeeds, the
taker retrieves the maker's public key, calculates the SHA-256 hash of the encrypted payload byte array to obtain the
signed data, and then attempts to verify the message's signature. If signature verification fails, the taker discards
the message and continues to listen for a valid message. If signature verification succeeds, the taker creates byte
arrays from the Base64-encoded strings in the message's "encryptedKey" and "encryptedIV" fields. If byte array creation
fails, the taker discards the message and continues to listen for a valid message. If byte array creation succeeds, the
taker retrieves the private key associated with the interface id in the message's "recipient" field (which is the
maker's interface id) and attempts to decrypt the encrypted key and initialization vector byte arrays. If decryption
fails, the taker discards the message and continues listening for a valid message. If decryption succeeds, the taker
creates a byte array from the Base64-encoded string in the message's "payload" and attempts to decrypt it using the
decrypted key and initialization vector. If byte array creation or payload decryption fails, the taker discards the
message and continues listening for a valid message. If byte array creation and decryption succeeds, the taker attempts
to restore the payload JSON from the decrypted byte array. If restoration fails, the taker discards the message and
continues to listen for a valid message. If restoration succeeds, the taker ensures that the payload's "msgType" field
equals "makerInfo". If it does not, the taker discards the message and continues listening for a valid message. If it
does, the taker creates a byte array from the Base64-encoded string in the payload's "swapId" field and compares it to
the swap id specified in the emitted OfferTaken event. If byte array creation fails or the two do not match, the taker
discards the message and continues to listen for a valid message. If the two do match, the taker creates a byte array
from the Base64-encoded string in the payload's "paymentDetails" field and attempts to restore the payment details JSON
from the byte array. If byte array creation or JSON restoration fails, the taker discards the message and continues to
listen for a valid message. If byte array creation and JSON restoration succeed, the taker checks that the payment
details correspond to the payment method that the taker chose when taking the offer. If they do not match, the taker
discards the message and continues to listen for a valid message. If they do match, the taker has confirmed that the
payment details contained in the message supplied by the maker are valid, and so the taker stores the maker's payment
details locally.
Then the taker sets the status of their local swap object to "receivedMakerInfo".
If the swap is a maker-as-seller swap, both the maker and the taker begin to listen for the emission of a SwapFilled
event corresponding to their swap. Then the maker-as-seller calls Commuto Protocol's fillSwap function, passing the UUID
of the swap and locking the swap amount of STBL in escrow. Once the maker and taker detect the emission of the
SwapFilled event corresponding to their maker-as-seller swap, they both update the status of their local swap objects to
"makerAsSellerDepositLocked".
Phase 2:
The buyer and seller both begin to listen for the emission of a PaymentSent event corresponding to their swap.
The buyer sends fiat payment to the seller using the previously agreed-upon payment method and details and in the
agreed-upon fiat currency denomination, and calls the Commuto Protocol's reportPaymentSent function and passes the UUID
of the swap. Once the buyer and seller detect the emission of the PaymentSent event corresponding to their swap, they
both update the status of their local swap objects to "paymentSent".
The buyer and seller both begin to listen for the emission of a PaymentReceived event corresponding to their swap.
Once the seller receives fiat payment, they call the reportPaymentReceived function, passing the UUID of the swap. Once
the buyer and seller detect the emission of the PaymentReceived event corresponding to their swap, they both update the
status of their local swap objects to "paymentReceived".
The buyer and seller both call the Commuto Protocol's closeSwap function in order to receive their STBL. When the buyer
detects the emission of a BuyerClosed event corresponding to the swap, the buyer marks their local swap object as
"closed". When the seller detects the emission of a SellerClosed event corresponding to the swap, the seller marks their
local swap object as "closed".

#TODO: Maker and Taker should begin listening for DisputeRaised events as soon as an offer is taken
The following is a description of how Interfaces will interact with each other and with the on-chain Commuto Protocol as
described in the whitepaper in order to raise and resolve disputes.
The maker or taker of an open swap decides to raise a dispute, and calls the Commuto Protocol's raiseDispute function,
passing the ID of the swap and the addresses of three different active dispute agents that the dispute raiser wishes to
resolve the dispute. When the dispute raiser detects the emission of the DisputeRaised event corresponding to their
newly raised dispute, they update the dispute status of their local swap object to "raisedDispute" and prepare the
following two JSON strings:
(the message JSON string)
{
"sender":[the dispute raiser's interface id as a Base64 string],
"msgType":"disputeUserPka", (dispute -> this message is sent as part of the dispute resolution process, user -> this
message is being sent by a user rather than a dispute agent, pka -> public key announcement)
"payload": null,
"signature": null
}
and (the payload JSON string)
{
"pubKey":[the same public key that the dispute raiser already created for the swap, in string format]
}
The dispute raiser converts the payload JSON string to UTF-8 bytes, creates a Base64-encoded string from those bytes,
and sets the "payload" field in the first string equal to the result. Then the dispute raiser calculates the SHA-256
hash of the JSON string's UTF-8 byte representation, signs it with their private key, and sets the "signature" field in
the first string equal to the Base64-encoded string representation of the signature. Then the maker sends the first
string as a message in the CIN Matrix room. When the message is successfully sent, the dispute raiser updates the
dispute status of the local swap object to "sentDisputePka". Then the dispute raiser begins listening for public key
announcements from all three dispute agents (that is, messages with the "senderEthAddr" field equal to one of the
Ethereum addresses of the three dispute agents as specified in the DisputeRaised event, with the "msgType" field equal
to "disputeAgent0Pka", "disputeAgent1Pka" or "disputeAgent2Pka", according to the address specified in the message's
"senderEthAddr" field, and the ["payload"]["swapId"] field equal to the id of the disputed swap, as specified in the
DisputeRaised event).
The first dispute agent (corresponding to the "disputeAgent0" field in the dispute raiser's call to raiseDispute) comes
online and checks for the emission of DisputeRaised events specifying their address. When the first dispute agent
discovers the new DisputeRaised event, they call the Commuto Protocol's getSwap function, passing the ID of the swap as
specified in the DisputeRaised event. They then use the information in the returned EVM compatible Swap object to create
and save a new local dispute object with all the information about the swap. Then they generate and store a new 2048-bit
RSA key pair, associate this key pair's corresponding interface id with the local dispute object, and set the dispute
object's status to "firstKeyPairGenerated". Then the first dispute agent creates the following two JSON strings:
(the message JSON string)
{
"sender":[the interface id of the first dispute agent's newly generated key pair as a Base64 string],
"senderEthAddr":[the first dispute agent's Ethereum address as specified in the DisputeRaised event],
"msgType":"disputeAgent0Pka", (dispute -> this message is sent as part of the dispute resolution process, agent0 -> this
message is being sent by the first dispute agent, pka -> public key announcement)
"payload": null,
"signature": null,
"signatureEth": null
}
and (the payload JSON string)
{
"pubKey":[the public key of the first dispute agent's newly generated key pair, in string format]
"swapId":[the id of the swap being disputed in Base64-encoded string format]
}
The first dispute agent converts the payload JSON string to UTF-8 bytes, creates a Base64-encoded string from those
bytes, and sets the "payload" field in the first string equal to the result. Then the first dispute agent calculates the
SHA-256 hash of the JSON string's UTF-8 byte representation, signs it with their private key, and sets the "signature"
field in the first string equal to the Base64-encoded string representation of the signature. Then the first dispute
agent signs the hash with the Ethereum private key corresponding to their Ethereum address, as specified in the
DisputeRaised event and in the "senderEthAddr" field of the first string, and sets the "signatureEth" field in the first
string equal to the Base64-encoded string representation of this second signature. Then the first dispute agent sends
the first string as a message in the CIN Matrix room. When the message is successfully sent, the first dispute agent
updates the status of the local dispute object to "sentDisputeAgent0Pka".
Then the first dispute agent creates three AES-256 keys. The first key is known as the Maker Communication Key (MCK) and
will be shared with the maker and the other two dispute agents. The second key is known as the Taker Communication Key
(TCK) and will be shared with the taker and the other two dispute agents. The third key is known as the Dispute Agent
Communication Key and will be shared with the other two dispute agents. Once the first dispute agent has created these
keys, they associate them with the local dispute object and save them. Then they update the status of the local dispute
object to "createdCommunicationKeys".
Then the first dispute agent begins listening for public key announcements from the other two dispute agents (that is,
messages with the "senderEthAddr" field equal to one of the Ethereum addresses of the other two dispute agents as
specified in the DisputeRaised event, with the "msgType" field equal to "disputeAgent1Pka" or "disputeAgent2Pka",
according to the address specified in the message's "senderEthAddr" field, and the ["payload"]["swapId"] field equal to
the id of the disputed swap, as specified in the DisputeRaised event) and for the public key announcement from the
dispute raiser (that is, a message with the "sender" field equal to the maker's interface id if the dispute raiser is
the maker, or equal to the taker's interface id if the dispute raiser is the taker and with the "msgType" field equal to
"disputeUserPka") and for the public key announcement from the dispute raiser's counterparty (that is, a message with
the "sender" field equal to the maker's interface id if the dispute raiser is the taker, or equal to the taker's
interface id if the dispute raiser is the maker and with the "msgType" field equal to "disputeUserPka").
The dispute raiser's counterparty comes online and checks for the emission of a DisputeRaised event specifying the id of
their swap. When they discover the DisputeRaised event, they update the dispute status of their local swap object to
"counterpartyRaisedDispute" and prepare the following two JSON strings:
(the message JSON string)
{
"sender":[the non-dispute-raising counterparty's interface id as a Base64 string]
"msgType":"disputeUserPka",
"payload": null,
"signature": null
}
and (the payload JSON string)
{
"pubKey": [the same public key that the non-dispute-raising counterparty already created for the swap, in string format
}
The non-dispute-raising counterparty converts the payload JSON string to UTF-8 bytes, creates a Base64-encoded string
from those bytes, and sets the "payload" field in the first string equal to the result. Then the dispute raiser
calculates the SHA-256 hash of the JSON string's UTF-8 byte representation, signs it with their private key, and sets
the "signature" field in the first string equal to the Base64-encoded string representation of the signature. Then the
non-dispute-raising counterparty sends the first string as a message in the CIN Matrix room. When the message is
successfully sent, the dispute raiser updates the dispute status of the local swap object to "sentDisputePka". Then the
non-dispute-raising counterparty begins listening for public key announcements from the all three dispute agents (that
is, messages with the "senderEthAddr" field equal to one of the Ethereum addresses of the three dispute agents as
specified in the DisputeRaised event, with the "msgType" field equal to "disputeAgent0Pka", "disputeAgent1Pka" or
"disputeAgent2Pka", according to the address specified in the message's "senderEthAddr" field, and the
["payload"]["swapId"] field equal to the id of the disputed swap, as specified in the DisputeRaised event).
When the first dispute agent finds a message in JSON string format with the "msgType" field equal to "disputeUserPka"
and the "sender" field equal to the interface id of the dispute raiser, they create a byte array from the Base64-encoded
string in the message's "payload" field and attempt to restore the payload JSON from the byte array. If restoration
fails, the first dispute agent discards the message and continues to listen for a valid message. If restoration
succeeds, the first dispute agent creates a public key from the Base64-encoded string in the payload's "pubKey" field,
creates a byte array from the Base64-encoded string in the message's "sender" field, and compares the interface id of
the public key to the byte array. If the two do not match, the first dispute agent discards the message and continues to
listen for a valid message. If the two do match, the first dispute agent restores the signature byte array from the
Base64-encoded string in the "signature" field and attempts to verify the signature using this byte array, the restored
public key, and the SHA-256 hash of the payload byte array. If signature verification fails, the first dispute agent
discards the message and continues to listen for a valid message. If signature verification succeeds, the first dispute
agent has confirmed that the key contained in the message is the dispute raiser's public key, and so the first dispute
agent associates the dispute raiser's public key with the dispute raiser's interface id and stores them locally. The
first dispute agent updates the status of their local dispute object to indicate that they have received the dispute
raiser's public key, and then they prepare the following two JSON strings:
(the message JSON string)
{
"sender": [the first dispute agent's interface id as a Base64 string],
"recipient": [the dispute raiser's interface id as a Base64 string],
"encryptedKey": null,
"encryptedIV": null,
"payload": null,
"signature": null
}
and (the payload JSON string)
{
"msgType": "MCKAnnouncement" if the dispute raiser is the maker, or "TCKAnnouncement" if the dispute raiser is the taker
"swapId": [the id of the disputed swap in Base64-encoded string format]
"key": [the Maker Communication Key or Taker Communication Key, depending on whether the dispute raiser is the maker or
taker, as a Base64-encoded string]
}
The first dispute agent converts the payload JSON string into a UTF-8 byte array, generates a new AES-256 key and 128
bit initialization vector, encrypts the byte array with the new key and initialization vector, and sets the "payload"
field in the message string equal to the Base64-encoded string representation of the encrypted byte array. Then the
first dispute agent calculates the SHA-256 hash of the encrypted byte array, signs it with their private key, and sets
the "signature" field in the message string equal to the Base64-encoded string representation of the signature. Then the
first dispute agent encrypts the AES-256 key and initialization vector using the dispute raiser's public key, and sets
the "encryptedKey" and "encryptedIV" fields in the message string equal to the respective Base64-encoded string results.
Then the first dispute agent sends the message string as a message in the CIN Matrix room, and updates the status of
their local dispute object to indicate that that they have sent the proper communication key to the dispute raiser.
When the first dispute agent finds a message in JSON string format with the "msgType" field equal to "disputeUserPka"
and the "sender" field equal to the interface id of the non-dispute-raising counterparty, they create a byte array from
the Base64-encoded string in the message's "payload" field and attempt to restore the payload JSON from the byte array.
If restoration succeeds, the first dispute agent creates a public key from the Base64-encoded string in the payload's
"pubKey" field, creates a byte array from the Base64-encoded string in the message's "sender" field, and compares the
interface id of the public key to the byte array. If the two do not match, the first dispute agent discards the message
and continues to listen for a valid message. If the two do match, the first dispute agent restores the signature byte
array from the Base64-encoded string in the "signature" field and attempts to verify the signature using this byte
array, the restored public key, and the SHA-256 hash of the payload byte array. If signature verification fails, the
first dispute agent discards the message and continues to listen for a valid message. If signature verification
fails, the first dispute agent discards the message and continues to listen for a valid message. If signature
verification succeeds, the first dispute agent has confirmed that the key contained in the message is the
non-dispute-raising counterparty's public key, and so the first dispute agent associates the non-dispute-raising
counterparty's public key with the non-dispute-raising counterparty's interface id and stores them locally. The first
dispute agent updates the status of their local dispute object to indicate that they have received the
non-dispute-raising counterparty's public key, and then they prepare the following two JSON strings:
(the message JSON string)
{
"sender": [the first dispute agent's interface id as a Base64 string],
"recipient": [the non-dispute-raising counterparty's interface id as a Base64 string]
"encryptedKey": null,
"encryptedIV": null,
"payload": null,
"signature": null
}
and (the payload JSON string)
{
"msgType": "MCKAnnouncement" if the non-dispute-raising counterparty is the maker, or "TCKAnnouncement" if the
non-dispute-raising counterparty is the taker
"swapId": [the id of the disputed swap in Base64-encoded string format]
"key": [the Maker Communication Key or Taker Communication Key, depending on whether the non-dispute-raising
counterparty is the maker or taker, as a Base64-encoded string]
}
The first dispute agent converts the payload JSON string into a UTF-8 byte array, generates a new AES-256 key and 128
bit initialization vector, encrypts the byte array with the new key and initialization vector, and sets the "payload"
field in the message string equal to the Base64-encoded string representation of the encrypted byte array. Then the
first dispute agent calculates the SHA-256 hash of the encrypted byte array, signs it with their private key, and sets
the "signature" field in the message string equal to the Base64-encoded string representation of the signature. Then the
first dispute agent encrypts the AES-256 key and initialization vector using the non-dispute-raising counterparty's
public key, and sets the "encryptedKey" and "encryptedIV" fields in the message string equal to the respective
Base64-encoded string results. Then the first dispute agent sends the message string as a message in the CIN Matrix
room, and updates the status of their local dispute object to indicate that they have sent the proper communication key
to the non-dispute-raising counterparty.
The second and third dispute agents (corresponding to the "disputeAgent1" and "disputeAgent2" fields in the dispute
raiser's call to raiseDispute) come online and check for the emission of DisputeRaised events specifying their
addresses. When they discover the new DisputeRaised event, they call the Commuto Protocol's getSwap function, passing
the ID of the swap as specified in the DisputeRaised event. They then use the information in the returned EVM compatible
Swap struct to create and save a new local dispute object with all the information about the swap. The two dispute
agents then each generate and store a new 2048-bit RSA key pair, associate the key pair's corresponding interface id
with their local dispute object, and set their dispute object's status to "keyPairGenerated". Then they each create the
following two JSON strings:
(the message JSON string)
{
"sender":[the interface id of the dispute agent's newly generated key pair as a Base64 string],
"senderEthAddr":[the dispute agent's Ethereum address as specified in the DisputeRaised event],
"msgType":"disputeAgent1Pka" if the sender is the second dispute agent specified in the DisputeRaised event, or
"disputeAgent2Pka" if the sender is the third dispute agent specified in the DisputeRaised event
"payload": null,
"signature": null,
"signatureEth": null
}
and (the payload JSON string)
{
"pubKey":[the public key of the dispute agent's newly generated key pair, in string format]
"swapId":[the id of the swap being disputed in Base64-encoded string format]
}
Each of two dispute agents converts their payload JSON string into UTF-8 bytes, creates a Base64-encoded string from
those bytes, and sets the "payload" field in the first string equal to the result. Then they each calculate the SHA-256
hash of the JSON string's UTF-8 byte representation, sign it with their private key, and set the "signature" field in
the first string equal to the Base64-encoded string representation of the signature. Then they each sign their hash with
their Ethereum private key corresponding to their Ethereum address, as specified in the DisputeRaised event and in the
"senderEthAddr" field of the first string, and set the "signatureEth" field in the first string equal to the
Base64-encoded string representation of this second signature. Then both of the two dispute agents send the first string
as a message in the CIN Matrix room. When their message is successfully sent, the second and third dispute agents each
update the status of their local dispute objects to "sentDisputeAgent1Pka" and "sentDisputeAgent2Pka", respectively.
Then the second and third dispute agents begin listening for public key announcements from each other and from the first
dispute agent (that is, messages with the "senderEthAddr" field equal to one of the Ethereum addresses of the other two
dispute agents as specified in the DisputeRaised event, with the "msgType" field equal to "disputeAgent0Pka" or
"disputeAgent1Pka" or "disputeAgent2Pka", according to the address specified in the message's "senderEthAddr" field, and
the ["payload"]["swapId"] field equal to the id of the disputed swap, as specified in the DisputeRaised event) and from
the dispute raiser and from the non-dispute-raising counterparty.
Dispute agents two and three obtain, verify and store the public keys of the dispute raiser and the non-dispute-raising
counterparty in the same way that the first dispute agent obtains these keys. Just as the first dispute agent does, they
each update the status of their local dispute object to indicate that they have received the public keys of the dispute
raiser and non-dispute-raising counterparty.
Each of the three dispute agents obtains the public keys of the other two dispute agents with the following process:
When a dispute agent finds a message in JSON string format with the "msgType" field equal to "disputeAgent0Pka" or
"disputeAgent1Pka" or "disputeAgent2Pka" (depending on the role of the dispute agent), the "senderEthAddr" field
equal to the Ethereum address of the dispute agents as specified in the DisputeRaised event and the message's "msgType"
field and the ["payload"]["swapId"] field equal to the id of the disputed swap, they create a byte array from the
Base64-encoded string in the message's "payload" field and attempt to restore the payload JSON from the byte array. If
restoration fails, the dispute dispute agent discards the message and continues to listen for a valid message. If
restoration succeeds, the first dispute agent restores the signature byte array from the Base64-encoded string in the
"signatureEth" field and attempts to verify the signature using this byte array, the Ethereum address in the
"senderEthAddr" field, and the SHA-256 hash of the payload byte array. If this signature verification fails, the dispute
agent discards the message and continues to listen for a valid message. If signature verification succeeds, the dispute
agent creates a public key from the Base64-encoded string in the payload's "pubKey" field, creates a byte array from the
Base64-encoded string in the message's "sender" field, and compares the interface id of the public key to the byte
array. If the two do not match, the dispute agent discards the message and continues to listen for a valid message. If
the two do match, the dispute agent restores the signature byte array from the Base64-encoded string in the "signature"
field and attempts to verify the signature using this byte array, the restored public key, and the SHA-256 hash of the
payload byte array. If signature verification fails, the dispute agent discards the message and continues to listen for
a valid message. If signature verification succeeds, the dispute agent has confirmed that the key contained in the
message is the public key of another dispute agent involved in resolving the disputed swap, and so the dispute agent
associates this interface id as that of the proper dispute agent involved with a certain dispute, updates their proper
local dispute object accordingly to indicate that they have received the public key of another dispute agent, and
associates the public key with the interface id and stores them locally. The second and third dispute agents begin
listening for a message from the first dispute agent containing communication keys (that is, a message with the "sender"
field equal to the interface id of the first dispute agent and the "msgtype" field in the payload equal to
"fullCommunicationKeyAnnouncement"). The dispute raiser and non-dispute-raising counterparty obtain and verify the
public keys of each dispute agent in exactly the same manner as the dispute agents obtain each others' public keys. When
the dispute raiser and non-dispute-raising counterparty obtain the public key of a dispute agent, they associate the
dispute agent's interface id with their local swap object and the Ethereum address of the dispute agent, and associate
the public key with the interface id and store them locally. Then they begin listening for a message from the first
dispute agent containing communication keys (that is, a message with the "sender" field equal to the interface id of the
first dispute agent, the "recipient" field equal to their own interface id used for the swap, and the "msgtype" field in
the payload equal to "MCKAnnouncement" in the case of the maker and "TCKAnnouncement" in the case of the taker).
Once they have the first dispute agent's public key, the dispute raiser and non-dispute-raising counterparty both obtain
the communication keys created and shared by the first dispute agent with the following process:
When the maker/taker of the disputed swap finds a message in JSON string format with the "sender" field equal to the
interface id of the first dispute agent selected for the disputed swap, they attempt to create an encrypted payload
byte array from the Base64-encoded string in the message's "payload" field. If byte array creation fails, the
maker/taker discards the message and continues listening for another valid message. If byte array creation succeeds, the
maker/taker attempts to restore the signature byte array from the Base64-encoded string in the "signature" field. If
byte array restoration fails, the maker/taker discards the message and continues listening for another valid message. If
byte array restoration succeeds, the maker/taker retrieves the first dispute agent's public key, calculates the SHA-256
hash of the encrypted payload byte array to obtain the signed data, and then attempts to verify the message's signature.
If signature verification fails, the maker/taker discards the message and continues listening for another valid message.
If signature verification succeeds, the maker/taker creates byte arrays from the Base64-encoded strings in the message's
"encryptedKey" and "encryptedIV" fields. If byte array creation fails, the maker/taker discards the message and
continues to listen for a valid message. If byte array creation succeeds, the maker/taker attempts to decrypt the
encrypted key and initialization vector byte arrays using their private key. If decryption fails, the maker/taker
discards the message and continues listening for a valid message. If decryption succeeds, the maker/taker creates a byte
array from the Base64-encoded string in the message's "payload" field and attempts to decrypt it using the decrypted key
and initialization vector. If byte array creation or payload decryption fails, the maker/taker discards the message and
continues listening for a valid message. If byte array creation and decryption succeeds, the maker/taker attempts to
restore the payload JSON from the decrypted byte array. If restoration fails, the maker/taker discards the message and
continues to listen for a valid message. If restoration succeeds, the maker/taker ensures that the payload's "msgType"
field equals "MCKAnnouncement" or "TCKAnnouncement" in the case of the maker and taker, respectively. If it does not,
the maker/taker discards the message and continues listening for a valid message. If it does, the maker/taker creates a
byte array from the Base64-encoded string in the payload's "swapId" field and compares it to the id of the disputed
swap. If byte array creation fails or the two do not match, the maker/taker discards the message and continues to listen
for a valid message. If the two do match, the maker/taker creates a symmetric key object from the Base64-encoded string
in the payload's "key" field, associates it with their local swap object, and updates the status of their local swap
object to indicate that they have received the communication key. Then they begin listening for the emission of
ResolutionProposed events for their swap and for chat messages from the dispute agents (that is, messages with the
"sender" field equal to the interface ids of any of the three dispute agents, and with the "recipient" field equal to
the maker's/taker's interface id).
Once the first dispute agent has received the public keys of the second and third dispute agent, the first dispute
agent prepares the following two JSON strings:
(the message JSON string)
{
"sender":[the first dispute agent's interface id]
"recipient":[a list containing the interface ids of the second and third dispute agent]
"encryptedKeyDA1": null,
"encryptedIVDA1": null,
"encryptedKeyDA2": null,
"encryptedIVDA2": null,
"payload": null,
"signature": null
}
and (the payload JSON string)
{
"msgType":"fullCommunicationKeyAnnouncement",
"swapId":[the id of the disputed swap in Base64-encoded string format]
"MCK":[the Maker Communication Key as a Base64-encoded string]
"TCK":[the Taker Communication Key as a Base64-encoded string]
}
The first dispute agent converts the payload JSON string into a UTF-8 byte array, generates a new 128 bit initialization
vector, encrypts the byte array with the Dispute Agent Communication Key and new initialization vector, and sets the
"payload" field in the message string equal to the Base64-encoded string representation of the encrypted byte array.
Then the first dispute agent calculates the SHA-256 hash of the encrypted byte array, signs it with their private key,
and sets the "signature" field in the message string equal to the Base64-encoded string representation of the signature.
Then the first dispute agent encrypts the Dispute Agent Communication Key and initialization vector with the second
dispute agent's public key, and sets the "encryptedKeyDA1" and "encryptedIVDA1" fields in the message string equal to
the respective Base64-encoded string results. Then the first dispute agent encrypts the Dispute Agent Communication Key
and initialization vector with the third dispute agent's public key, and sets the "encryptedKeyDA2" and "encryptedIVDA2"
fields in the message string equal to the respective Base64-encoded string results. Then the first dispute agent sends
the message string as a message in the CIN Matrix room, and updates the status of their local dispute object to indicate
that they have sent the full communication key announcement to the other two dispute agents. Then the first dispute
agent begins listening for the emission of ResolutionProposed events for the swap and for chat messages from the dispute
agents, from the dispute raiser and from the non-dispute-raising counterparty (that is, messages with the "sender" field
equal to the interface ids of any of the other two dispute agents, the dispute raiser, or the non-dispute-raising
counterparty, and with the first dispute agent's interface id as an element of the list in the "recipient" field).
Once they have the first dispute agent's public key, the second and third dispute agents obtain both communication keys
created and shared by the first dispute agent with the following process:
When the second/third dispute agent for the disputed swap finds a message in JSON string format with the "sender" field
equal to the interface id of the first dispute agent selected for the disputed swap, they attempt to create an encrypted
payload byte array from the Base64-encoded string in the message's "payload" field. If byte array creation fails, the
second/third dispute agent discards the message and continues listening for another valid message. If byte array
creation succeeds, the second/third dispute agent attempts to restore the signature byte array from the Base64-encoded
string in the message's "signature" field. If restoration fails, the second/third dispute agent discards the message and
continues listening for another valid message. If restoration succeeds, the second/third dispute agent retrieves the
first dispute agent's public key, calculates the SHA-256 hash of the encrypted payload byte array to obtain the signed
data, and then attempts to verify the message's signature. If verification fails, the second/third dispute agent
discards the message and continues listening for another valid message. If verification succeeds, the second/third
dispute agent creates byte arrays from the Base64-encoded strings in the message's "encryptedKeyDA1"/"encryptedKeyDA2"
and "encryptedIVDA1"/"encryptedIVDA2" fields. If byte array creation fails, the second/third dispute agent discards the
message and continues to listen for a valid message. If byte array creation succeeds, the second/third dispute agent
attempts to decrypt the encrypted key and initialization vector byte arrays using their private key. If decryption
fails, the second/third dispute agent discards the message and continues listening for a valid message. If decryption
succeeds, the second/third dispute agent creates a symmetric key object from the decrypted key data and creates a byte
array from the Base64-encoded string in the message's "payload" field and attempts to decrypt it using the decrypted
key and initialization vector. If byte array creation or decryption fails, the second/third dispute agent discards the
message and continues listening for a valid message. If byte array creation or decryption succeeds, the second/third
dispute agent attempts to restore payload JSON from the decrypted byte array. If restoration fails, the second/third
dispute agent discards the message and continues listening for a valid message. If restoration succeeds, the
second/third dispute agent ensures that the payload's "msgType" field equals "fullCommunicationKeyAnnouncement". If it
does not, the second/third dispute agent discards the message and continues listening for a valid message. If it does,
the second/third dispute agent creates a byte array from the Base64-encoded string in the payload's "swapId" field and
compares it to the id of the disputed swap. If byte array creation fails or the two do not match, the second/third
dispute agent discards the message and continues to listen for a valid message. If the two do match, the second/third
dispute agent creates symmetric key objects from the Base64-encoded string in the payload's "MCK" and "TCK" fields,
associates these two keys with their corresponding dispute object as the Maker Communication Key and Taker Communication
Key, associates the decrypted key from the "encryptedKeyDA1"/"encryptedKeyDA2" field with the dispute object as the
Dispute Agent Communication Key, and updates the status of their dispute object to indicate that they have received
all three communication keys. Then they begin listening for the emission of ResolutionProposed events for the swap and
for chat messages from the other dispute agents, from the dispute raiser and from the non-dispute-raising counterparty
(that is, messages with the "sender" field equal to the interface ids of any of the other two dispute agents, the
dispute raiser, or the non-dispute-raising counterparty, and with their interface id as an element of the list in the "
recipient" field).
At this point, each dispute agent has all three communication keys, the maker has the Maker Communication Key, the taker
has the Taker Communication Key, and every party involved in the dispute has the public key of every other party.
Using the Maker Communication Key, the maker and the three dispute agents can privately communicate with each other,
such that all messages sent by any one of them are visible to all four. The taker and all three dispute agents can
communicate in the same way using the Taker Communication Key, and the dispute agents can communicate with each other in
the same way using the Dispute Agent Communication Key. They prepare and send messages with the following process:
The message sender prepares two JSON strings:
(the message JSON string)
{
"sender": [the interface id of the message sender, which is either the dispute raiser, the non-dispute-raising
counterparty, or one of the three dispute agents]
"recipient":[a list of the interface ids of the message recipients. If the sender is the maker or one of the dispute
agents trying to communicate with the maker, this list will contain the maker's interface id and the interface ids of
the three dispute agents, minus the interface id of the sender. If the sender is the taker or one of the three dispute
agents trying to communicate with the taker, this list will contain the the taker's interface id and the interface ids
of the three dispute agents, minus the interface id of the sender. If the sender is one of the three dispute agents
trying to communicate only with the other two dispute agents, this list will contain the two interface ids of the
dispute agents that are not the sender]
"encryptedIVDA0":[this field will be present when the sender is not the first dispute agent]
"encryptedIVDA1":[this field will be present when the sender is not the second dispute agent]
"encryptedIVDA2":[this field will be present when the sender is not the third dispute agent]
"encryptedIVMkr":[this field will be present when the sender is a dispute agent and is trying to communicate with the
maker and the other two dispute agents]
"encryptedIVTkr":[this field will be present when the sender is a dispute agent and is trying to communicate with the
taker and the other two dispute agents]
"payload": null,
"signature": null
}
and (the payload JSON string)
{
"msgType":"disputeChatText",
"swapId":[the id of the disputed swap in Base64-encoded string format]
"content":[the text of the chat message as a string]
}
The sender converts the payload JSON string into a UTF-8 byte array, generates a new 128 bit initialization vector,
encrypts the byte array with the proper communication key (the Maker Communication Key if the sender is the maker or a
dispute agent attempting to communicate with the maker, the Taker Communication Key if the sender is the taker or a
dispute agent attempting to communicate with the taker, or the Dispute Agent Communication Key if the sender is one of
the dispute agents attempting to communicate with the other two dispute agents) and sets the "payload" field in the
message string equal to the Base64-encoded string representation of the encrypted byte array. Then the sender calculates
the SHA-256 hash of the encrypted byte array, signs it with their private key, and sets the "signature" field in the
message string equal to the Base64-encoded string representation of the signature. Then the sender encrypts the
initialization vector with the public key of each recipient, and sets all the "encryptedIV..." fields in the message
string equal to the proper Base64-encoded string results. Then the sender sends the message string as a message in the
CIN Matrix room.
When a message recipient finds a message in JSON string format with their interface id in the list of interface ids in
the "recipient" field and the "sender" field equal to the interface id of one of the parties involved in the resolution
of their dispute, they attempt to create an encrypted payload byte array from the Base64-encoded string in the message's
"payload" field. If byte array creation fails, the recipient discards the message. If byte array creation succeeds, the
recipient attempts to restore the signature byte array from the Base64-encoded string in the message's "signature"
field. If restoration fails, the recipient discards the message. If restoration succeeds, the recipient retrieves the
public key of the sender, calculates the SHA-256 hash of the encrypted payload byte array to obtain the signed data,
and then attempts to verify the message's signature. If verification fails, the recipient discards the message. If
verification succeeds, the recipient creates a byte array from the encrypted initialization vector in the proper
"encryptedIV..." field ("encryptedIVMkr" if the recipient is the maker, "encryptedIVTkr" if the recipient is the taker,
or one of the "encryptedIVDA..." fields if the recipient is a dispute agent). If byte array creation fails, the
recipient discards the message. If byte array creation succeeds, the recipient attempts to decrypt the encrypted
initialization vector using their private key. If decryption fails, the recipient discards the message. If decryption
succeeds, the recipient creates a byte array from the Base64-encoded data in the message's "payload" field and attempts
to decrypt it using the decrypted initialization vector and the proper communication key (the Maker Communication Key
if one of the interface ids in the "recipient" list is the maker, the Taker Communication Key if one of the interface
ids in the "recipient" list is the taker, or the Dispute Agent Communication Key otherwise). If byte array creation or
decryption fails, the recipient discards the message. If byte array creation or decryption succeeds, the recipient
attempts to restore payload JSON from the decrypted byte array. If restoration fails, the recipient discards the
message. If restoration succeeds, the recipient checks that the payload's "msgType" field equals "disputeChatText". If
it does, the recipient discards the message. If it does, the recipient creates a byte array from the Base64-encoded
string in the payload's "swapId" field and compares it to the id of the disputed swap. If the two do not match, the
recipient discards the message. If the two do match, the recipient stores the value in the payload's "content" field
as a new chat message.
Once the parties involved in the resolution of the dispute detect the emission of two ResolutionProposed events, the
begin to listen for DisputeEscalated or DisputedSwapClosed events. Once one of these events has been emitted, the
dispute is either resolved or escalated. In either case, the dispute agents are no longer required and thus they stop
listening for the emission of events related to the dispute. Additionally, all parties involved stop listening for
messages related to the dispute.


first dispute agent creates and stores key pair, announces public key with eth key signature, and creates and saves
three symmetric keys: one to share with the dispute raiser and the other two dispute agents, one to share with the
dispute-raiser's counterparty and the other two dispute agents, and one to share only with the other two dispute agents.
Then the first dispute agent begins listening for public key announcements from the other two dispute agents and from
the dispute raiser and from the dispute raiser's counterparty. non-dispute-raising counterparty comes online, checks
for DisputeRaised event, realizes dispute has been raised, updates local swap object, and announces public key. then
begins listening for public key announcements from dispute agents. Once the first dispute agent hears the dispute
raiser's public key announcement, they store the dispute raiser's public key and encrypt the first symmetric key with
the dispute raiser's public key and send it in the CIN Matrix room. Once the first dispute agent hears the dispute
raiser's counterparty's public key announcement, they store the counterparty's public key and encrypt the second
symmetric key with the counterparty's public key and send it in the CIN Matrix room. the other two dispute agents
come online and listen for DisputeRaised events. Once they detect the dispute raiser's DisputeRaised event, they begin
listening for the dispute raiser's public key announcement, the counterparty's public key announcement and the first
dispute agent's public key announcement. They each generate and store a new key pair and announce their public key with
eth key signature. They find and store each other's keys upon discovering them. dispute raiser discovers and verifies
each dispute agent's public key announcement, saves keys locally, and then starts listening for symmetric key.
non-dispute-raising counterparty discovers and verifies each dispute agent's public key announcement, saves keys
locally, and then starts listening for symmetric key. dispute raiser discovers and verifies the symmetric key message,
saves key locally, and then starts listening for messages and ResolutionProposed events. non-dispute-raising
counterparty discovers and verifies symmetric key messages, saves key locally and then starts listening for messages
and ResolutionProposed events. Once the first dispute agent hears the second and third dispute agents' public key
announcements, the first dispute agent creates a message containing all three symmetric keys. Then they encrypt a copy
of the message with the second dispute agent's public key and encrypt another copy of the message with the third dispute
agent's public key. Then the first dispute agent signs the encrypted messages and sends them in the CIN Matrix room.
Dispute agents two and three discover and verify all three symmetric key messages, save keys locally, and then start
listening for messages and ResolutionProposed events.At this point, all three dispute agents have all three symmetric
keys, the dispute raiser has the first symmetric key, and the counterparty has the second symmetric key. Using the
first key, the dispute raiser can communicate privately with the dispute agents. Using the second key, the counterparty
can communicate privately with the dispute agents. And using the third key, the dispute agents can communicate privately
with each other. dispute agents stop listening for messages once the disputed swap is either escalated or closed (done)

Commuto Interface Network Specification:
//TODO: Eventually, each Interface should have its own Matrix homeserver built in, to regularly create "throwaway" accounts
//TODO: Clarify interactions with KMService
The Interface shall have a CINService instance. The CINService is responsible for receiving and acting on requests from
other services belonging to the same Interface instance (Local Services) to send messages to other Interfaces, or to
broadcast messages to every Interface. The CINService is responsible for listening for, discovering, validating and
interpreting messages received from other Interfaces, and then passing on the validated and interpreted results to the
appropriate Local Services.
//TODO: Update this to include interface version in JSON
//TODO: RSA keys shouldn't be used to encrypt message payload. An AES key should be used instead, and then the AES key should be encrypted with the recipiants public key, and that should be included in JSON in some sort of "encrypted key" field
Local Services can request that a message be sent by calling the CINService's sendMessage method. When this sendMessage
method is called, the caller must pass a message object. The sendMessage method then generates a JSON string
representation of the message's data. Then the sendMessage method determines if the message is a Broadcast message which
may be read by all Interfaces, or if the message is a Direct message, which should only be read by a specific interface:
If the message object's recipientInterfaceID field is empty, CINService determines it is a Broadcast message. If the
message object's recipientInterfaceID field is not empty, CINService determines it is a Direct message. If the message
is a Broadcast message, then CINService creates a new JSON string with the following fields: "sender", "payload" and
"signature". CINService sets the "sender" field to the message object's senderInterfaceID field, and the "payload" field
to the JSON string representation of the message's data. Then CINService obtains the private key associated with the
message object's senderInterfaceID field, generates a hash of the JSON string representation of the message's data,
signs this hash with the obtained private key, and sets the "signature" field to this resulting signature. Then
CINService sends this message in the Commuto Interface Network Matrix room. If the message is a Direct message, then
CINService creates a new JSON string with the following fields: "sender", "recipient", "payload" and "signature".
CINService sets the "sender" field to the message object's senderInterfaceID field, and the recipient field to the
message object's recipientInterfaceID field. Then CINService obtains the public key associated with the message object's
recipientInterfaceID field, uses it to encrypt the JSON string representation of the message object's data, and then
sets the "payload" field to the result. Then CINService obtains the private key associated with the message object's
senderInterfaceID field, generates a hash of the JSON string representation of the message's data, signs this hash with
the obtained private key, and sets the "signature" field to this resulting signature. Then CINService sends this message
in the Commuto Interface Network Matrix room.
By default, CINService does not listen for messages in the Commuto Interface Network Matrix room. Local Services can
request that CINService listen for specific messages by calling the CINService's expectMessage method. When this
expectMessage method is called, the caller must pass a MessageExpectation object. This MessageExpectation object is then
added to CINService's list of active MessageExpectation objects. A MessageExpectation object describes the attributes of
messages for which CINService should search, and also specifies which Local Service should receive validated,
interpreted messages with attributes matching those specified in the MessageExpectation object, when the CINService
discovers such messages. When one or more MessageExpectations is/are active, CINService compares each new message in the
Commuto Interface Network Matrix room with each MessageExpectation object in CINService's list of active
MessageExpectation objects. If a message matches a MessageExpectation, then CINService, after validating the message and
decrypting it as necessary, passes it to the Local Service specified in the MessageExpectation. If a message does not
match any MessageExpectations, it is dropped. MessageExpectations specify certain message fields, and for each specified
message field, a MessageExpectation specifies possible values for that particular message field. These possible values
are known as patterns. In addition to arbitrary text strings, there are three special pattern values: Present, which
expresses a requirement that a message contains a certain field and a value for that field, though the actual value
itself is not considered. Empty, which expresses a requirement that a message contains a certain field and no value for
that field (the field is empty). Not_Present, which expresses a requirement that a message does not contain a certain
field. CINService determines that a message matches a MessageExpectation in the following manner: For each message field
specified in the MessageExpectation object, that field must be present in the message, unless the MessageExpectation
object specifies a Not_Present value for that field, in which case the field must not be present. The value of that
field must be empty if the MessageExpectation object specifies an Empty value for that field, or must have any value if
the MessageExpectation object specifies a Present value for that field, or otherwise must have a value equal to the
pattern specified for that value by the MessageExpectation object. If all of these conditions are met, then CINService
determines that the message matches the MessageExpectation and that the message is expected by the service that created
the MessageExpectation, and, after validating the message and decrypting it as necessary, passes it to the Local Service
specified in the Message. Once the Local Service has received the message, the Local Service evaluates it to determine
if it is a message that the Local Service is expecting. If the Local Service determines that it has received the message
it expected, it then requests that CINService stops listening for such messages by calling the CINService's
removeMessageExpectation method. To call this method, the calling Local Service must create and pass to the method a
MessageExpectation identical to the MessageExpectation the Local Service created earlier, describing the attributes of
the message that the Local Service was expecting but now has received. Then, CINService searches through its list of
active MessageExpectations, and removes any that are identical to the MessageExpectation passed to the
removeMessageExpectation method.
//TODO: create one big, META ME, such that if a packet matches any current MEs, they match the meta ME, then have the Matrix Homeserver filter the messages it serves using this ME. Though this has to happen at the Matrix Homeserver level, so it will have to be a seperate thing
By default, CINService attempts to validate every message before carrying out any other processing. Public Key
Announcement messages are validated slightly differently than all other types of messages. The user may optionally
configure CINService to skip message validation on Broadcast messages. In order to validate a message that is not a
Public Key Announcement message, CINService obtains the public key associated with the message's senderInterfaceID,
generates a hash of the value in the message's "payload" field, and then uses the obtained public key to verify that the
signature in the message's "signature" field is a valid signature of the hash of the "payload" data. If the signature is
valid, CINService continues processing the message. Otherwise, CINService drops the message. In order to validate a
Public Key Announcement message, CINService notes the new public key included in the message's "payload" field,
generates a hash of the value in the message's "payload" field, and then uses the noted public key to verify that the
signature in the message's "signature" field is a valid signature of the hash of the "payload" data. If the signature is
valid, CINService continues processing the Public Key Announcement message. Otherwise, CINService drops the message.
Before CINService can analyze the payload of a Direct message, it must first decrypt the payload. To do this, CINService
obtains the private key associated with the value in the message's recipientInterfaceID field, decrypts the payload
using this private key, and carries on its analysis of the message. If the attempt to obtain the key fails or decryption
fails, CINService drops the message.
CINService receives and parses messages in JSON string format. When CINService has determined that a message is expected
by a Local Service, CINService creates a message object with the JSON string's data and passes that message object to
the proper Local Service.
A Local Service can cause CINService to actively search for old messages matching one or more MessageExpectations by
calling CINService's expectOldMessage method. To do this, a Local Service must specify: either a date/time interval or a
single date/time, and either a single MessageExpectation or a list of MessageExpectations. If a Local Service specifies
a date/time interval, then CINService searches for messages matching the passed MessageExpectation(s) within all
messages sent in the Commuto Interface Network Matrix room within the specified date/time interval. If a Local Service
specifies only a single date/time, then CINService searches for messages matching the passed MessageExpectation(s)
within all messages sent in the Commuto Interface Network Matrix room beginning at the specified date/time and up to and
including the most recent message. If a Local Service passes a single MessageExpectation, then CINService will pass all
messages matching the MessageExpectation to the Local Service specified in the MessageExpectation. If a Local Service
passes a list of MessageExpectations, then CINService will compare each message to each MessageExpectation, and will
pass all messages matching a MessageExpectation to the Local Service specified in the MessageExpectation.
Upon Interface shutdown, CINService persistently stores the timestamp at which the last message that CINService
processed was sent. Upon Interface startup, CINService waits for a signal from every Local Service indicating that the
Local Service is properly initialized, and has passed to CINService all necessary MessageExpectations. When such a
signal has been received from every Local Service, CINService searches for messages matching all active
MessageExpectations within all messages sent in the Commuto Interface Network Matrix room since the time described by
the timestamp of the last-processed message before the Interface's most recent shutdown.

Commuto Interface Key Manager Service Specification:
The Interface shall have a KMService instance. The KMService is responsible for generating key pairs and their
accompanying Interface ID, storing the Interface's own key pairs along with each pair's corresponding Interface ID,
validating and storing other Interfaces' public keys along with each key's corresponding Interface ID, and serving
the Interface's own key pairs and other Interface's public keys to other Local Services on demand, given an Interface
ID.
An Interface ID is a SHA-256 hash of an Interface's RSA public key in PKCS#1 byte encoded format. Interfaces may have
more than one Interface ID, since a new key pair and Interface ID is created for every swap offer. A Local Service can
request that KMService generate a new key pair and Interface ID by calling KMService's key generation method:
generateKeyPair()
    Generates a new 2048-bit RSA key pair and derives the Interface ID by taking the SHA-256 hash of the
    new public key in PKCS#1 byte encoded format. Computes the Base64 string encoded PKCS#1 representations of the
    newly generated public and private keys and the Base64 string representation of the derived Interface ID and
    persistently stores them using DBService.storeKeyPair. Returns the Interface ID, public key and private key to the
    caller.
A Local Service can request its Interface's own key pairs from KMService by calling KMService's method:
getKeyPair(interfaceId)
    where interfaceId is the SHA-256 hash of the desired key pair's public key in PKCS#1 byte encoded format. Computes
    the Base64 string representation of interfaceId and retrieves the key pair in Base64 string encoded PKCS#1 format by
    passing the resulting representation of interfaceId to DBService.getKeyPair. Recreates public and private key
    objects using the strings returned by DBService.getKeyPair. Returns interfaceId, public key and private key to the
    caller.
A Local Service can request that KMService stores an Interface's public key by calling KMService's method:
storePublicKey(pubKey)
    where pubKey is a public key object. Derives the Interface ID by taking the SHA-256 hash of pubKey in PKCS#1 byte
    encoded format. Computes the Base64 string encoded PKCS#1 representation of pubKey and the Base64 string
    representation of the derived Interface ID and persistently stores them using DBService.storePublicKey.
A Local Service can request other Interfaces' public keys from KMService by calling KMService's method:
getPublicKey(interfaceId)
    where interfaceId is the SHA-256 hash of the desired public key in PKCS#1 byte encoded format. Computes the Base64
    string representation of interfaceId and retrieves the public key in Base64 string encoded PKCS#1 format by passing
    the resulting representation of interfaceId to DBService.getPublicKey. Recreates the public key object using the
    string returned by DBService.getPublicKey. Returns interfaceId and the public key to the caller.

Commuto Interface Database Service Specification
The Interface shall have a DBService instance. The DBService is responsible for persistently storing the Interface's
data, serving this data to Local Services upon request, and accepting Local Services' requests to add and remove data
from storage.
The DBService shall have the following functions exclusively for use by KMService:
storeKeyPair(interfaceId, publicKey, privateKey)
    Associates publicKey and privateKey with interfaceId and stores them in the Interface's SQL database.
getKeyPair(interfaceId)
    Searches the Interface's SQL database for a key pair associated with the supplied value of interfaceId. Throws an
    error if more than one key pair is found. Returns interfaceId, public key and private key if one key pair is found.
    Returns nothing if no key pair is found.
storePublicKey(interfaceId, publicKey)
    Associates publicKey with interfaceId and stores them in the Interface's SQL database.
getPublicKey(interfaceId)
    Searches the Interface's SQL database for a public key associated with the supplied value of interfaceId. Throws an
    error if more than one public key is found. Returns interfaceId and public key if a public key is found. Returns
    nothing if no public key is found.
where interfaceId, publicKey and privateKey are strings.


Needs to:
For CINService:
Store Matrix Credentials
For KMService:
Store own private + public key pairs along with their interface ID
Serve these upon request
Add new upon request
Store other public keys along with their interface ID
Serve these upon request
Add new upon request
For Open Offer Service (not yet designed):
Add/Remove Open Offers
Handle pending taken-by-own-interface offers
For Swaps Service (not yet designed):
Add Taken Swaps
Associate chat messages with taken swaps
Associate payment method info with taken swaps